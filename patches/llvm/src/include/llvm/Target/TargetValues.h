//===----- llvm/Target/TargetValues.h - Value Properties ----*- C++ -----*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file provides an API for detecting properties of architecture-specific
// values & for generating a series of simple metadata instructions for
// reconstituting a value.  This is used by the stack transformation runtime to
// set up architecture-specific live values.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_TARGET_TARGETVAL_H
#define LLVM_TARGET_TARGETVAL_H

#include <memory>
#include <set>
#include <vector>
#include "llvm/CodeGen/StackTransformTypes.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/VirtRegMap.h"
#include "llvm/IR/Instructions.h"

namespace llvm {

/// A value created by the backend to satisfy the stackmap.  Note that this is
/// not necessarily an error -- some backends may create and save the value
/// whereas other backends may materialize the value as needed.
struct TemporaryValue {
  enum type {
    StackSlotRef
  };

  enum type Type;
  unsigned Size;

  /// The virtual register used if the temporary is stored in a register
  unsigned Vreg;

  /// If the value is of type StackSlotRef, the stack slot and offset into the
  /// stack slot being referenced
  int StackSlot;
  int64_t Offset;
};

typedef std::unique_ptr<TemporaryValue> TemporaryValuePtr;

//===----------------------------------------------------------------------===//
// Superclass for ISA-specific values
//

class TargetValues {
public:
  TargetValues(const TargetValues &) = delete;
  void operator=(const TargetValues &) = delete;
  virtual ~TargetValues() {};

  /// Return the base register used to address argument space on the stack
  virtual unsigned getArgSpaceBaseReg() const { return 0; }

  /// Find all registers used for argument passing for a given call instruction
  /// and return the number of registers used to pass arguments.
  virtual void getArgRegs(const MachineInstr *MICall,
                          std::vector<unsigned> &regs) const
  { regs.clear(); }

  /// Find all stack pointer offsets used as argument passing space for the
  /// given call instruction and return the total amount of space used for
  /// passing arguments.
  virtual int64_t getArgSlots(const MachineInstr *MICall,
                              std::set<int64_t> &offsets) const
  { offsets.clear(); return 0; }

  /// The code generator may have materialized a temporary value solely to
  /// satisfy the stackmap if the value is materialized as-needed elsewhere.
  /// Return metadata describing the temporary value in this situation.
  virtual TemporaryValuePtr getTemporaryValue(const MachineInstr *MI,
                                              const VirtRegMap *VRM) const
  { return nullptr; }

  /// Return a machine-specific value generated by a machine instruction.
  virtual MachineLiveValPtr getMachineValue(const MachineInstr *MI) const = 0;

  /// Add any required architecture-specific live values, e.g., the TOC pointer
  /// on PowerPC.
  virtual void addRequiredArchLiveValues(MachineFunction *MF,
                                         const MachineInstr *MIStackMap,
                                         const CallInst *IRStackMap) const
  { return; }

protected:
  TargetValues() {}

  /// Return whether or not the operand is some type of symbol reference.
  static bool isSymbolValue(const MachineOperand &MO)
  { return MO.isGlobal() || MO.isSymbol() || MO.isMCSymbol(); }
  static bool isSymbolValue(const MachineOperand *MO)
  { return isSymbolValue(*MO); }
  static bool isSymbolValueConstant(const MachineOperand &MO);
  static bool isSymbolValueConstant(const MachineOperand *MO)
  { return isSymbolValueConstant(*MO); }
};

} // End llvm namespace

#endif

