Index: include/clang/AST/DataRecursiveASTVisitor.h
===================================================================
--- include/clang/AST/DataRecursiveASTVisitor.h	(revision 320332)
+++ include/clang/AST/DataRecursiveASTVisitor.h	(working copy)
@@ -2663,6 +2663,14 @@
   return true;
 }
 
+template <typename Derived>
+bool RecursiveASTVisitor<Derived>::VisitOMPPrefetchClause(OMPPrefetchClause *C) {
+  TRY_TO(VisitOMPClauseList(C));
+  TRY_TO(TraverseStmt(C->getStartOfRange()));
+  TRY_TO(TraverseStmt(C->getEndOfRange()));
+  return true;
+}
+
 // FIXME: look at the following tricky-seeming exprs to see if we
 // need to recurse on anything.  These are ones that have methods
 // returning decls or qualtypes or nestednamespecifier -- though I'm
Index: include/clang/AST/OpenMPClause.h
===================================================================
--- include/clang/AST/OpenMPClause.h	(revision 320332)
+++ include/clang/AST/OpenMPClause.h	(working copy)
@@ -2300,6 +2300,59 @@
   }
 };
 
+/// \brief This represents a memory prefetch request for Popcorn Linux.  This
+/// should only be used for prefetching contiguous blocks of memory, e.g.,
+/// arrays or pointers to chunks of memory.
+class OMPPrefetchClause : public OMPVarListClause<OMPPrefetchClause> {
+private:
+  /// \brief What type of prefetching to perform.
+  OpenMPPrefetchClauseKind Kind;
+
+  /// \brief Expressions describing the memory range to be prefetched.
+  ///
+  /// 1. If both are nullptr, then the entire array should be prefetched
+  /// 2. If Start is valid and End is nullptr, then use the expression (which
+  ///    should be affine to a for-loop iteration variable) to prefetch the
+  ///    region of memory based on the loop iterations assigned to the thread
+  /// 3. If both Start and End are valid, then prefetch the absolute range
+  ///    denoted by the starting & ending expressions
+  Expr *Start, *End;
+
+  /// \brief Locations of the kind specifier, colons used to separate the
+  /// variable list and range expression(s).  These are valid in conjunction
+  /// with Start & End, respectively.
+  SourceLocation KindLoc, FirstColonLoc, SecondColonLoc;
+
+  OMPPrefetchClause(SourceLocation StartLoc, SourceLocation LParenLoc,
+                    SourceLocation FirstColonLoc,
+                    SourceLocation SecondColonLoc, SourceLocation EndLoc,
+                    unsigned N)
+      : OMPVarListClause<OMPPrefetchClause>(OMPC_prefetch, StartLoc, LParenLoc,
+                                            EndLoc, N),
+        FirstColonLoc(FirstColonLoc), SecondColonLoc(SecondColonLoc) {}
+public:
+  static OMPPrefetchClause *
+  Create(const ASTContext &C, OpenMPPrefetchClauseKind Kind,
+         SourceLocation KindLoc, ArrayRef<Expr *> VL, Expr *Start, Expr *End,
+         SourceLocation StartLoc, SourceLocation LParenLoc,
+         SourceLocation FirstColonLoc, SourceLocation SecondColonLoc,
+         SourceLocation EndLoc);
+
+  OpenMPPrefetchClauseKind getPrefetchKind() const { return Kind; }
+  void setPrefetchKind(OpenMPPrefetchClauseKind Kind) { this->Kind = Kind; }
+
+  Expr *getStartOfRange() const { return Start; }
+  void setStartOfRange(Expr *Start) { this->Start = Start; }
+  Expr *getEndOfRange() const { return End; }
+  void setEndOfRange(Expr *End) { this->End = End; }
+
+  SourceLocation getPrefetchKindLoc() const { return KindLoc; }
+  void setPrefetchKindLoc(SourceLocation Loc) { KindLoc = Loc; }
+  SourceLocation getFirstColonLoc() const { return FirstColonLoc; }
+  SourceLocation getSecondColonLoc() const { return SecondColonLoc; }
+
+};
+
 } // end namespace clang
 
 #endif
Index: include/clang/AST/RecursiveASTVisitor.h
===================================================================
--- include/clang/AST/RecursiveASTVisitor.h	(revision 320332)
+++ include/clang/AST/RecursiveASTVisitor.h	(working copy)
@@ -2695,6 +2695,14 @@
   return true;
 }
 
+template <typename Derived>
+bool RecursiveASTVisitor<Derived>::VisitOMPPrefetchClause(OMPPrefetchClause *C) {
+  TRY_TO(VisitOMPClauseList(C));
+  TRY_TO(TraverseStmt(C->getStartOfRange()));
+  TRY_TO(TraverseStmt(C->getEndOfRange()));
+  return true;
+}
+
 // FIXME: look at the following tricky-seeming exprs to see if we
 // need to recurse on anything.  These are ones that have methods
 // returning decls or qualtypes or nestednamespecifier -- though I'm
Index: include/clang/AST/Stmt.h
===================================================================
--- include/clang/AST/Stmt.h	(revision 320332)
+++ include/clang/AST/Stmt.h	(working copy)
@@ -2069,6 +2069,12 @@
   /// \brief The record for captured variables, a RecordDecl or CXXRecordDecl.
   RecordDecl *TheRecordDecl;
 
+  /// \brief For captured OpenMP parallel regions, variables declared in the
+  /// shared clause may be stored on the main thread's stack.  This causes
+  /// false sharing in Popcorn's distributed execution.  If set, offload shared
+  /// variables to global memory for the capture.
+  bool OffloadShared;
+
   /// \brief Construct a captured statement.
   CapturedStmt(Stmt *S, CapturedRegionKind Kind, ArrayRef<Capture> Captures,
                ArrayRef<Expr *> CaptureInits, CapturedDecl *CD, RecordDecl *RD);
@@ -2134,6 +2140,10 @@
   /// \brief True if this variable has been captured.
   bool capturesVariable(const VarDecl *Var) const;
 
+  /// \brief Getters/setters for the offloading shared variables flag
+  bool offloadShared() const { return OffloadShared; }
+  void setOffloadShared(bool OS) { OffloadShared = OS; }
+
   /// \brief An iterator that walks over the captures.
   typedef Capture *capture_iterator;
   typedef const Capture *const_capture_iterator;
Index: include/clang/AST/StmtOpenMP.h
===================================================================
--- include/clang/AST/StmtOpenMP.h	(revision 320332)
+++ include/clang/AST/StmtOpenMP.h	(working copy)
@@ -42,6 +42,8 @@
   const unsigned NumClauses;
   /// \brief Number of child expressions/stmts.
   const unsigned NumChildren;
+  /// \brief Enable prefetching code generation for Popcorn Linux
+  bool Prefetch;
   /// \brief Offset from this to the start of clauses.
   /// There are NumClauses pointers to clauses, they are followed by
   /// NumChildren pointers to child stmts/exprs (if the directive type
@@ -69,7 +71,7 @@
                          unsigned NumClauses, unsigned NumChildren)
       : Stmt(SC), Kind(K), StartLoc(std::move(StartLoc)),
         EndLoc(std::move(EndLoc)), NumClauses(NumClauses),
-        NumChildren(NumChildren),
+        NumChildren(NumChildren), Prefetch(false),
         ClausesOffset(llvm::RoundUpToAlignment(sizeof(T),
                                                llvm::alignOf<OMPClause *>())) {}
 
@@ -205,6 +207,9 @@
   ArrayRef<OMPClause *> clauses() const {
     return const_cast<OMPExecutableDirective *>(this)->getClauses();
   }
+
+  bool prefetchingEnabled() const { return Prefetch; }
+  void setPrefetching(bool Prefetch) { this->Prefetch = Prefetch; }
 };
 
 /// \brief This represents '#pragma omp parallel' directive.
Index: include/clang/Basic/DiagnosticParseKinds.td
===================================================================
--- include/clang/Basic/DiagnosticParseKinds.td	(revision 320332)
+++ include/clang/Basic/DiagnosticParseKinds.td	(working copy)
@@ -993,6 +993,14 @@
   "'#pragma omp %0' cannot be an immediate substatement">;
 def err_omp_expected_identifier_for_critical : Error<
   "expected identifier specifying the name of the 'omp critical' directive">;
+def err_omp_invalid_prefetch_kind : Error<
+  "invalid argument; expected 'read' or 'write'">;
+// TODO Technically these are semantics issues, but we're doing checking in the
+// parser for this particular clause
+def err_omp_invalid_prefetch_capture : Error<
+  "can only prefetch variables used in the loop body">;
+def err_omp_invalid_prefetch_loop_var : Error<
+  "can only prefetch loop iteration range using a loop iteration variable">;
 
 // Pragma loop support.
 def err_pragma_loop_missing_argument : Error<
Index: include/clang/Basic/DiagnosticSemaKinds.td
===================================================================
--- include/clang/Basic/DiagnosticSemaKinds.td	(revision 320332)
+++ include/clang/Basic/DiagnosticSemaKinds.td	(working copy)
@@ -7649,6 +7649,10 @@
   "parent region for 'omp %select{cancellation point/cancel}0' construct cannot be nowait">;
 def err_omp_parent_cancel_region_ordered : Error<
   "parent region for 'omp %select{cancellation point/cancel}0' construct cannot be ordered">;
+def err_omp_invalid_prefetch_var_type : Error<
+  "invalid variable type; must be %0 type">;
+def err_omp_invalid_prefetch_range_type : Error<
+  "invalid range specifier type; must be of integer (signed or unsigned) type">;
 } // end of OpenMP category
 
 let CategoryName = "Related Result Type Issue" in {
Index: include/clang/Basic/LangOptions.def
===================================================================
--- include/clang/Basic/LangOptions.def	(revision 320332)
+++ include/clang/Basic/LangOptions.def	(working copy)
@@ -230,6 +230,9 @@
                                            "field padding (0: none, 1:least "
                                            "aggressive, 2: more aggressive)")
 
+// Optimize OpenMP code generation for distributed execution on Popcorn Linux
+BENIGN_LANGOPT(DistributedOmp, 1, 0, "Optimize OpenMP for distributed execution")
+
 #undef LANGOPT
 #undef COMPATIBLE_LANGOPT
 #undef BENIGN_LANGOPT
Index: include/clang/Basic/OpenMPKinds.def
===================================================================
--- include/clang/Basic/OpenMPKinds.def	(revision 320332)
+++ include/clang/Basic/OpenMPKinds.def	(working copy)
@@ -72,6 +72,9 @@
 #ifndef OPENMP_DEPEND_KIND
 #define OPENMP_DEPEND_KIND(Name)
 #endif
+#ifndef OPENMP_PREFETCH_KIND
+#define OPENMP_PREFETCH_KIND(Name)
+#endif
 
 // OpenMP directives.
 OPENMP_DIRECTIVE(threadprivate)
@@ -129,6 +132,7 @@
 OPENMP_CLAUSE(capture, OMPCaptureClause)
 OPENMP_CLAUSE(seq_cst, OMPSeqCstClause)
 OPENMP_CLAUSE(depend, OMPDependClause)
+OPENMP_CLAUSE(prefetch, OMPPrefetchClause)
 
 // Clauses allowed for OpenMP directive 'parallel'.
 OPENMP_PARALLEL_CLAUSE(if)
@@ -159,6 +163,7 @@
 OPENMP_FOR_CLAUSE(schedule)
 OPENMP_FOR_CLAUSE(ordered)
 OPENMP_FOR_CLAUSE(nowait)
+OPENMP_FOR_CLAUSE(prefetch)
 
 // Clauses allowed for directive 'omp for simd'.
 OPENMP_FOR_SIMD_CLAUSE(private)
@@ -171,6 +176,7 @@
 OPENMP_FOR_SIMD_CLAUSE(safelen)
 OPENMP_FOR_SIMD_CLAUSE(linear)
 OPENMP_FOR_SIMD_CLAUSE(aligned)
+OPENMP_FOR_SIMD_CLAUSE(prefetch)
 
 // Clauses allowed for OpenMP directive 'omp sections'.
 OPENMP_SECTIONS_CLAUSE(private)
@@ -206,6 +212,10 @@
 OPENMP_DEPEND_KIND(out)
 OPENMP_DEPEND_KIND(inout)
 
+// Static attributes for 'prefetch' clause.
+OPENMP_PREFETCH_KIND(read)
+OPENMP_PREFETCH_KIND(write)
+
 // Clauses allowed for OpenMP directive 'parallel for'.
 OPENMP_PARALLEL_FOR_CLAUSE(if)
 OPENMP_PARALLEL_FOR_CLAUSE(num_threads)
@@ -220,6 +230,7 @@
 OPENMP_PARALLEL_FOR_CLAUSE(collapse)
 OPENMP_PARALLEL_FOR_CLAUSE(schedule)
 OPENMP_PARALLEL_FOR_CLAUSE(ordered)
+OPENMP_PARALLEL_FOR_CLAUSE(prefetch)
 
 // Clauses allowed for OpenMP directive 'parallel for simd'.
 OPENMP_PARALLEL_FOR_SIMD_CLAUSE(if)
@@ -237,6 +248,7 @@
 OPENMP_PARALLEL_FOR_SIMD_CLAUSE(safelen)
 OPENMP_PARALLEL_FOR_SIMD_CLAUSE(linear)
 OPENMP_PARALLEL_FOR_SIMD_CLAUSE(aligned)
+OPENMP_PARALLEL_FOR_SIMD_CLAUSE(prefetch)
 
 // Clauses allowed for OpenMP directive 'parallel sections'.
 OPENMP_PARALLEL_SECTIONS_CLAUSE(if)
@@ -280,6 +292,7 @@
 OPENMP_TEAMS_CLAUSE(shared)
 OPENMP_TEAMS_CLAUSE(reduction)
 
+#undef OPENMP_PREFETCH_KIND
 #undef OPENMP_DEPEND_KIND
 #undef OPENMP_SCHEDULE_KIND
 #undef OPENMP_PROC_BIND_KIND
Index: include/clang/Basic/OpenMPKinds.h
===================================================================
--- include/clang/Basic/OpenMPKinds.h	(revision 320332)
+++ include/clang/Basic/OpenMPKinds.h	(working copy)
@@ -70,6 +70,14 @@
   OMPC_DEPEND_unknown
 };
 
+/// \brief OpenMP attributes for 'prefetch' clause.
+enum OpenMPPrefetchClauseKind {
+#define OPENMP_PREFETCH_KIND(Name) \
+  OMPC_PREFETCH_##Name,
+#include "clang/Basic/OpenMPKinds.def"
+  OMPC_PREFETCH_unknown
+};
+
 OpenMPDirectiveKind getOpenMPDirectiveKind(llvm::StringRef Str);
 const char *getOpenMPDirectiveName(OpenMPDirectiveKind Kind);
 
Index: include/clang/CodeGen/BackendUtil.h
===================================================================
--- include/clang/CodeGen/BackendUtil.h	(revision 320332)
+++ include/clang/CodeGen/BackendUtil.h	(working copy)
@@ -28,13 +28,32 @@
     Backend_EmitLL,        ///< Emit human-readable LLVM assembly
     Backend_EmitNothing,   ///< Don't emit anything (benchmarking mode)
     Backend_EmitMCNull,    ///< Run CodeGen, but don't emit anything
-    Backend_EmitObj        ///< Emit native object files
+    Backend_EmitObj,       ///< Emit native object files
+    Backend_EmitMultiObj   ///< Emit native object files for multiple ISAs
   };
 
+  /// Run both IR optimization passes and backend passes to generate code
   void EmitBackendOutput(DiagnosticsEngine &Diags, const CodeGenOptions &CGOpts,
                          const TargetOptions &TOpts, const LangOptions &LOpts,
                          StringRef TDesc, llvm::Module *M, BackendAction Action,
                          raw_pwrite_stream *OS);
+
+  /// Run IR optimization passes
+  void ApplyIROptimizations(DiagnosticsEngine &Diags,
+                            const CodeGenOptions &CGOpts,
+                            const TargetOptions &TOpts,
+                            const LangOptions &LOpts,
+                            llvm::Module *M, BackendAction Action,
+                            raw_pwrite_stream *OS);
+
+  /// Run backend code-generation passes
+  void CodegenBackendOutput(DiagnosticsEngine &Diags,
+                            const CodeGenOptions &CGOpts,
+                            const TargetOptions &TOpts,
+                            const LangOptions &LOpts,
+                            StringRef TDesc, llvm::Module *M,
+                            BackendAction Action,
+                            raw_pwrite_stream *OS);
 }
 
 #endif
Index: include/clang/CodeGen/CodeGenAction.h
===================================================================
--- include/clang/CodeGen/CodeGenAction.h	(revision 320332)
+++ include/clang/CodeGen/CodeGenAction.h	(working copy)
@@ -11,6 +11,7 @@
 #define LLVM_CLANG_CODEGEN_CODEGENACTION_H
 
 #include "clang/Frontend/FrontendAction.h"
+#include "clang/CodeGen/BackendUtil.h"
 #include <memory>
 
 namespace llvm {
@@ -20,9 +21,10 @@
 
 namespace clang {
 class BackendConsumer;
+class CoverageSourceInfo;
 
 class CodeGenAction : public ASTFrontendAction {
-private:
+protected:
   unsigned Act;
   std::unique_ptr<llvm::Module> TheModule;
   llvm::Module *LinkModule;
@@ -29,7 +31,6 @@
   llvm::LLVMContext *VMContext;
   bool OwnsVMContext;
 
-protected:
   /// Create a new code generation action.  If the optional \p _VMContext
   /// parameter is supplied, the action uses it without taking ownership,
   /// otherwise it creates a fresh LLVM context and takes ownership.
@@ -37,6 +38,14 @@
 
   bool hasIRSupport() const override;
 
+  /// Helpers called in CreateASTConsumer
+  llvm::Module *getLinkModuleToUse(CompilerInstance &CI);
+  CoverageSourceInfo *getCoverageInfo(CompilerInstance &CI);
+
+  /// Helper called in ExecuteAction.  Returns true if the compilation is
+  /// invalid and should therefore be aborted.
+  bool ExecuteActionIRCommon(BackendAction &BA, CompilerInstance &CI);
+
   std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,
                                                  StringRef InFile) override;
 
@@ -98,6 +107,23 @@
   EmitObjAction(llvm::LLVMContext *_VMContext = nullptr);
 };
 
+/// Emit multiple object files using a single set of IR.  Used by the Popcorn
+/// Linux compiler toolchain.
+class EmitMultiObjAction : public CodeGenAction {
+  virtual void anchor();
+  SmallVector<std::string, 2> Targets;
+  SmallVector<raw_pwrite_stream *, 2> OutFiles;
+  SmallVector<std::shared_ptr<TargetOptions>, 2> TargetOpts;
+  SmallVector<TargetInfo *, 2> TargetInfos;
+protected:
+  bool InitializeTargets(CompilerInstance &CI, StringRef InFile);
+  std::unique_ptr<ASTConsumer> CreateASTConsumer(CompilerInstance &CI,
+                                                 StringRef InFile) override;
+  void ExecuteAction() override;
+public:
+  EmitMultiObjAction(llvm::LLVMContext *_VMContext = nullptr);
+};
+
 }
 
 #endif
Index: include/clang/CodeGen/PopcornUtil.h
===================================================================
--- include/clang/CodeGen/PopcornUtil.h	(nonexistent)
+++ include/clang/CodeGen/PopcornUtil.h	(working copy)
@@ -0,0 +1,47 @@
+//===--- PopcornUtil.h - Popcorn Linux Utilities ----------------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_CLANG_CODEGEN_POPCORNUTIL_H
+#define LLVM_CLANG_CODEGEN_POPCORNUTIL_H
+
+#include <llvm/ADT/StringRef.h>
+#include <llvm/IR/Module.h>
+#include <clang/Basic/TargetOptions.h>
+#include <memory>
+
+namespace clang {
+namespace Popcorn {
+
+/// Return whether a given target is supported by the compiler.
+bool SupportedTarget(const llvm::StringRef Target);
+
+/// Populate an array with all targets currently supported by the Popcorn
+/// compiler.
+void GetAllTargets(llvm::SmallVector<std::string, 2> &Targets);
+
+/// Return a TargetOptions with features appropriate for Popcorn Linux
+std::shared_ptr<TargetOptions>
+GetPopcornTargetOpts(const llvm::StringRef TripleStr);
+
+/// Strip target-specific CPUs & features from function attributes in all
+/// functions in the module.  This silences warnings from the compiler about
+/// unsupported target features when compiling the IR for multiple
+/// architectures.
+void StripTargetAttributes(llvm::Module &M);
+
+
+/// Add the target-features attribute specified in TargetOpts to every function
+/// in module M.
+void AddArchSpecificTargetFeatures(llvm::Module &M,
+                                   std::shared_ptr<TargetOptions> TargetOpts);
+
+} /* end Popcorn namespace */
+} /* end clang namespace */
+
+#endif
Index: include/clang/Driver/Options.td
===================================================================
--- include/clang/Driver/Options.td	(revision 320332)
+++ include/clang/Driver/Options.td	(working copy)
@@ -83,6 +83,8 @@
 def m_libc_Group          : OptionGroup<"<m libc group>">, Group<m_Group>;
 def u_Group               : OptionGroup<"<u group>">;
 
+def Popcorn_Target_Group  : OptionGroup<"<Popcorn target group>">, Group<CompileOnly_Group>;
+
 def pedantic_Group        : OptionGroup<"<pedantic group>">,
   Group<CompileOnly_Group>;
 def reserved_lib_Group   : OptionGroup<"<reserved libs group>">;
@@ -1538,6 +1540,12 @@
 def pg : Flag<["-"], "pg">, HelpText<"Enable mcount instrumentation">, Flags<[CC1Option]>;
 def pipe : Flag<["-", "--"], "pipe">,
   HelpText<"Use pipes between commands, when possible">;
+def popcorn_migratable : Flag<["-"], "popcorn-migratable">, HelpText<"Instrument code to be migratable on Popcorn Linux (implies -popcorn-alignment)">, Flags<[CC1Option]>;
+def popcorn_metadata : Flag<["-"], "popcorn-metadata">, HelpText<"Generate stack transformation metadata without inserting migration points (implies -popcorn-alignment)">, Flags<[CC1Option]>;
+def popcorn_libc : Flag<["-"], "popcorn-libc">, HelpText<"Compile libc code with appropriate instrumentation for migration (implies -popcorn-alignment)">, Flags<[CC1Option]>;
+def popcorn_alignment : Flag<["-"], "popcorn-alignment">, HelpText<"Run Popcorn passes to prepare for link-time symbol alignment">, Flags<[CC1Option]>;
+def popcorn_target : Joined<["-"], "popcorn-target=">, HelpText<"Targets for which to generate object files (requires -popcorn-migratable)">, Group<Popcorn_Target_Group>, Flags<[CC1Option]>, MetaVarName<"<target>">;
+def distributed_omp : Flag<["-"], "distributed-omp">, HelpText<"Optimize OpenMP code generation for distributed execution on Popcorn Linux">, Flags<[CC1Option]>;
 def prebind__all__twolevel__modules : Flag<["-"], "prebind_all_twolevel_modules">;
 def prebind : Flag<["-"], "prebind">;
 def preload : Flag<["-"], "preload">;
Index: include/clang/Frontend/CodeGenOptions.def
===================================================================
--- include/clang/Frontend/CodeGenOptions.def	(revision 320332)
+++ include/clang/Frontend/CodeGenOptions.def	(working copy)
@@ -158,6 +158,12 @@
 
 CODEGENOPT(EmitLLVMUseLists, 1, 0) ///< Control whether to serialize use-lists.
 
+/// Select places inside functions to instrument with migration points
+CODEGENOPT(PopcornMigratable, 1, 0)
+
+/// Adjust linkage of global values for symbol alignment
+CODEGENOPT(PopcornAlignment, 1, 0)
+
 /// The user specified number of registers to be used for integral arguments,
 /// or 0 if unspecified.
 VALUE_CODEGENOPT(NumRegisterParameters, 32, 0)
Index: include/clang/Frontend/CodeGenOptions.h
===================================================================
--- include/clang/Frontend/CodeGenOptions.h	(revision 320332)
+++ include/clang/Frontend/CodeGenOptions.h	(working copy)
@@ -201,6 +201,9 @@
   /// Set of sanitizer checks that trap rather than diagnose.
   SanitizerSet SanitizeTrap;
 
+  /// Targets for which to emit object code
+  std::vector<std::string> PopcornTargets;
+
 public:
   // Define accessors/mutators for code generation options of enumeration type.
 #define CODEGENOPT(Name, Bits, Default)
Index: include/clang/Frontend/CompilerInstance.h
===================================================================
--- include/clang/Frontend/CompilerInstance.h	(revision 320332)
+++ include/clang/Frontend/CompilerInstance.h	(working copy)
@@ -260,6 +260,13 @@
     return Invocation->getCodeGenOpts();
   }
 
+  CodeGenOptions &getCodeGenNoOpts() {
+    return Invocation->getCodeGenNoOpts();
+  }
+  const CodeGenOptions &getCodeGenNoOpts() const {
+    return Invocation->getCodeGenNoOpts();
+  }
+
   DependencyOutputOptions &getDependencyOutputOpts() {
     return Invocation->getDependencyOutputOpts();
   }
Index: include/clang/Frontend/CompilerInvocation.h
===================================================================
--- include/clang/Frontend/CompilerInvocation.h	(revision 320332)
+++ include/clang/Frontend/CompilerInvocation.h	(working copy)
@@ -108,6 +108,9 @@
   /// Options controlling IRgen and the backend.
   CodeGenOptions CodeGenOpts;
 
+  /// Options controlling IRgen and the backend (with optimization disabled).
+  CodeGenOptions CodeGenOptsNoOpt;
+
   /// Options controlling dependency output.
   DependencyOutputOptions DependencyOutputOpts;
 
@@ -179,6 +182,11 @@
     return CodeGenOpts;
   }
 
+  CodeGenOptions &getCodeGenNoOpts() { return CodeGenOptsNoOpt; }
+  const CodeGenOptions &getCodeGenNoOpts() const {
+    return CodeGenOptsNoOpt;
+  }
+
   DependencyOutputOptions &getDependencyOutputOpts() {
     return DependencyOutputOpts;
   }
Index: include/clang/Frontend/FrontendOptions.h
===================================================================
--- include/clang/Frontend/FrontendOptions.h	(revision 320332)
+++ include/clang/Frontend/FrontendOptions.h	(working copy)
@@ -37,6 +37,7 @@
     EmitLLVMOnly,           ///< Generate LLVM IR, but do not emit anything.
     EmitCodeGenOnly,        ///< Generate machine code, but don't emit anything.
     EmitObj,                ///< Emit a .o file.
+    EmitMultiObj,           ///< Emit a .o file for multiple ISAs.
     FixIt,                  ///< Parse and apply any fixits to the source.
     GenerateModule,         ///< Generate pre-compiled module.
     GeneratePCH,            ///< Generate pre-compiled header.
Index: include/clang/Parse/Parser.h
===================================================================
--- include/clang/Parse/Parser.h	(revision 320332)
+++ include/clang/Parse/Parser.h	(working copy)
@@ -2418,6 +2418,10 @@
 
   //===--------------------------------------------------------------------===//
   // OpenMP: Directives and clauses.
+  /// \brief Checks 'prefetch' clauses for correctness.  Note that we can only
+  /// perform some semantic checks *after* the entire compound statement
+  /// representing the directive's body has been parsed.
+  void CheckOpenMPPrefetchClauses(StmtResult Directive);
   /// \brief Parses declarative OpenMP directives.
   DeclGroupPtrTy ParseOpenMPDeclarativeDirective();
   /// \brief Parses simple list of variables.
Index: include/clang/Sema/Sema.h
===================================================================
--- include/clang/Sema/Sema.h	(revision 320332)
+++ include/clang/Sema/Sema.h	(working copy)
@@ -7950,11 +7950,12 @@
 
   OMPClause *ActOnOpenMPVarListClause(
       OpenMPClauseKind Kind, ArrayRef<Expr *> Vars, Expr *TailExpr,
-      SourceLocation StartLoc, SourceLocation LParenLoc,
-      SourceLocation ColonLoc, SourceLocation EndLoc,
-      CXXScopeSpec &ReductionIdScopeSpec,
+      Expr *EndExpr, SourceLocation StartLoc, SourceLocation LParenLoc,
+      SourceLocation ColonLoc, SourceLocation EndColonLoc,
+      SourceLocation EndLoc, CXXScopeSpec &ReductionIdScopeSpec,
       const DeclarationNameInfo &ReductionId, OpenMPDependClauseKind DepKind,
-      SourceLocation DepLoc);
+      SourceLocation DepLoc, OpenMPPrefetchClauseKind PrefKind,
+      SourceLocation PrefLoc);
   /// \brief Called on well-formed 'private' clause.
   OMPClause *ActOnOpenMPPrivateClause(ArrayRef<Expr *> VarList,
                                       SourceLocation StartLoc,
@@ -8018,6 +8019,18 @@
                           SourceLocation StartLoc, SourceLocation LParenLoc,
                           SourceLocation EndLoc);
 
+  /// \brief Called on well-formed 'prefetch' clause.
+  OMPClause *
+  ActOnOpenMPPrefetchClause(OpenMPPrefetchClauseKind PrefKind,
+                            SourceLocation PrefLoc,
+                            ArrayRef<Expr *> VarList,
+                            Expr *Start, Expr *End,
+                            SourceLocation StartLoc,
+                            SourceLocation LParenLoc,
+                            SourceLocation FirstColonLoc,
+                            SourceLocation SecondColonLoc,
+                            SourceLocation EndLoc);
+
   /// \brief The kind of conversion being performed.
   enum CheckedConversionKind {
     /// \brief An implicit conversion.
Index: lib/AST/Stmt.cpp
===================================================================
--- lib/AST/Stmt.cpp	(revision 320332)
+++ lib/AST/Stmt.cpp	(working copy)
@@ -1623,6 +1623,28 @@
   return nullptr;
 }
 
+OMPPrefetchClause *
+OMPPrefetchClause::Create(const ASTContext &C, OpenMPPrefetchClauseKind Kind,
+                          SourceLocation KindLoc, ArrayRef<Expr *> VL,
+                          Expr *Start, Expr *End, SourceLocation StartLoc,
+                          SourceLocation LParenLoc,
+                          SourceLocation FirstColonLoc,
+                          SourceLocation SecondColonLoc,
+                          SourceLocation EndLoc) {
+  void *Mem = C.Allocate(llvm::RoundUpToAlignment(sizeof(OMPPrefetchClause),
+                                                  llvm::alignOf<Expr *>()) +
+                         sizeof(Expr *) * VL.size());
+  OMPPrefetchClause *Clause =
+    new (Mem) OMPPrefetchClause(StartLoc, LParenLoc, FirstColonLoc, SecondColonLoc,
+                                EndLoc, VL.size());
+  Clause->setPrefetchKind(Kind);
+  Clause->setPrefetchKindLoc(KindLoc);
+  Clause->setStartOfRange(Start);
+  Clause->setEndOfRange(End);
+  Clause->setVarRefs(VL);
+  return Clause;
+}
+
 OMPParallelDirective *OMPParallelDirective::Create(
                                               const ASTContext &C,
                                               SourceLocation StartLoc,
Index: lib/AST/StmtPrinter.cpp
===================================================================
--- lib/AST/StmtPrinter.cpp	(revision 320332)
+++ lib/AST/StmtPrinter.cpp	(working copy)
@@ -810,7 +810,22 @@
     OS << ")";
   }
 }
+
+void OMPClausePrinter::VisitOMPPrefetchClause(OMPPrefetchClause *Node) {
+  if (!Node->varlist_empty()) {
+    OS << "prefetch(";
+    OS << getOpenMPSimpleClauseTypeName(Node->getClauseKind(),
+                                        Node->getPrefetchKind())
+       << " :";
+    VisitOMPClauseList(Node, ' ');
+    OS << ",";
+    Node->getStartOfRange()->printPretty(OS, nullptr, Policy, 0);
+    OS << ",";
+    Node->getEndOfRange()->printPretty(OS, nullptr, Policy, 0);
+    OS << ")";
+  }
 }
+}
 
 //===----------------------------------------------------------------------===//
 //  OpenMP directives printing methods
Index: lib/AST/StmtProfile.cpp
===================================================================
--- lib/AST/StmtProfile.cpp	(revision 320332)
+++ lib/AST/StmtProfile.cpp	(working copy)
@@ -428,7 +428,12 @@
 void OMPClauseProfiler::VisitOMPDependClause(const OMPDependClause *C) {
   VisitOMPClauseList(C);
 }
+void OMPClauseProfiler::VisitOMPPrefetchClause(const OMPPrefetchClause *C) {
+  VisitOMPClauseList(C);
+  Profiler->VisitStmt(C->getStartOfRange());
+  Profiler->VisitStmt(C->getEndOfRange());
 }
+}
 
 void
 StmtProfiler::VisitOMPExecutableDirective(const OMPExecutableDirective *S) {
Index: lib/Basic/OpenMPKinds.cpp
===================================================================
--- lib/Basic/OpenMPKinds.cpp	(revision 320332)
+++ lib/Basic/OpenMPKinds.cpp	(working copy)
@@ -96,6 +96,11 @@
 #define OPENMP_DEPEND_KIND(Name) .Case(#Name, OMPC_DEPEND_##Name)
 #include "clang/Basic/OpenMPKinds.def"
         .Default(OMPC_DEPEND_unknown);
+  case OMPC_prefetch:
+    return llvm::StringSwitch<OpenMPPrefetchClauseKind>(Str)
+#define OPENMP_PREFETCH_KIND(Name) .Case(#Name, OMPC_PREFETCH_##Name)
+#include "clang/Basic/OpenMPKinds.def"
+        .Default(OMPC_PREFETCH_unknown);
   case OMPC_unknown:
   case OMPC_threadprivate:
   case OMPC_if:
@@ -195,6 +200,7 @@
   case OMPC_update:
   case OMPC_capture:
   case OMPC_seq_cst:
+  case OMPC_prefetch:
     break;
   }
   llvm_unreachable("Invalid OpenMP simple clause kind");
Index: lib/CodeGen/BackendUtil.cpp
===================================================================
--- lib/CodeGen/BackendUtil.cpp	(revision 320332)
+++ lib/CodeGen/BackendUtil.cpp	(working copy)
@@ -15,6 +15,7 @@
 #include "clang/Frontend/FrontendDiagnostic.h"
 #include "clang/Frontend/Utils.h"
 #include "llvm/ADT/StringSwitch.h"
+#include "llvm/Analysis/Passes.h"
 #include "llvm/Analysis/TargetLibraryInfo.h"
 #include "llvm/Analysis/TargetTransformInfo.h"
 #include "llvm/Bitcode/BitcodeWriterPass.h"
@@ -39,6 +40,7 @@
 #include "llvm/Transforms/Instrumentation.h"
 #include "llvm/Transforms/ObjCARC.h"
 #include "llvm/Transforms/Scalar.h"
+#include "llvm/Transforms/Utils.h"
 #include "llvm/Transforms/Utils/SymbolRewriter.h"
 #include <memory>
 using namespace clang;
@@ -132,6 +134,16 @@
 
   std::unique_ptr<TargetMachine> TM;
 
+  /// Set up the assembly helper, including gathering passes
+  void SetupAssemblyHelper(BackendAction Action,
+                           raw_pwrite_stream *OS);
+
+  /// Run only IR optimization passes on a module
+  void ApplyIROptPasses(Module* TheModule);
+
+  /// Run backend passes to generate code
+  void ApplyCodegenPasses(Module* TheModule);
+
   void EmitAssembly(BackendAction Action, raw_pwrite_stream *OS);
 };
 
@@ -271,6 +283,18 @@
   MPM->add(createRewriteSymbolsPass(DL));
 }
 
+static void addPopcornMigPointPasses(const PassManagerBuilder &Builder,
+                                     legacy::PassManagerBase &PM) {
+  PM.add(createPopcornCompatibilityPass());
+  PM.add(createSelectMigrationPointsPass());
+}
+
+static void addPopcornAlignmentPasses(const PassManagerBuilder &Builder,
+                                      legacy::PassManagerBase &PM) {
+  PM.add(createNameStringLiteralsPass());
+  PM.add(createStaticVarSectionsPass());
+}
+
 void EmitAssemblyHelper::CreatePasses() {
   unsigned OptLevel = CodeGenOpts.OptimizationLevel;
   CodeGenOptions::InliningMethod Inlining = CodeGenOpts.getInlining();
@@ -420,6 +444,29 @@
     MPM->add(createInstrProfilingPass(Options));
   }
 
+  // Popcorn Compiler Toolchain passes -- add after IR optimization passes
+  // Select migration points.
+  if (CodeGenOpts.PopcornMigratable) {
+    if (OptLevel > 0)
+      PMBuilder.addExtension(PassManagerBuilder::EP_OptimizerLast,
+                             addPopcornMigPointPasses);
+    else {
+      MPM->add(createPopcornCompatibilityPass());
+      MPM->add(createSelectMigrationPointsPass());
+    }
+  }
+
+  // Adjust global symbol linkage for alignment.
+  if (CodeGenOpts.PopcornAlignment) {
+    if (OptLevel > 0)
+      PMBuilder.addExtension(PassManagerBuilder::EP_OptimizerLast,
+                             addPopcornAlignmentPasses);
+    else {
+      MPM->add(createNameStringLiteralsPass());
+      MPM->add(createStaticVarSectionsPass());
+    }
+  }
+
   PMBuilder.populateModulePassManager(*MPM);
 }
 
@@ -570,7 +617,7 @@
   // Normal mode, emit a .s or .o file by running the code generator. Note,
   // this also adds codegenerator level optimization passes.
   TargetMachine::CodeGenFileType CGFT = TargetMachine::CGFT_AssemblyFile;
-  if (Action == Backend_EmitObj)
+  if (Action == Backend_EmitObj || Action == Backend_EmitMultiObj)
     CGFT = TargetMachine::CGFT_ObjectFile;
   else if (Action == Backend_EmitMCNull)
     CGFT = TargetMachine::CGFT_Null;
@@ -592,8 +639,8 @@
   return true;
 }
 
-void EmitAssemblyHelper::EmitAssembly(BackendAction Action,
-                                      raw_pwrite_stream *OS) {
+void EmitAssemblyHelper::SetupAssemblyHelper(BackendAction Action,
+                                             raw_pwrite_stream *OS) {
   TimeRegion Region(llvm::TimePassesIsEnabled ? &CodeGenerationTime : nullptr);
 
   bool UsesCodeGen = (Action != Backend_EmitNothing &&
@@ -629,7 +676,9 @@
 
   // Before executing passes, print the final values of the LLVM options.
   cl::PrintOptionValues();
+}
 
+void EmitAssemblyHelper::ApplyIROptPasses(Module* M) {
   // Run passes. For now we do all passes at once, but eventually we
   // would like to have the option of streaming code generation.
 
@@ -647,7 +696,9 @@
     PrettyStackTraceString CrashInfo("Per-module optimization passes");
     PerModulePasses->run(*TheModule);
   }
+}
 
+void EmitAssemblyHelper::ApplyCodegenPasses(Module* M) {
   if (CodeGenPasses) {
     PrettyStackTraceString CrashInfo("Code generation");
     CodeGenPasses->run(*TheModule);
@@ -654,6 +705,13 @@
   }
 }
 
+void EmitAssemblyHelper::EmitAssembly(BackendAction Action,
+                                      raw_pwrite_stream *OS) {
+  SetupAssemblyHelper(Action, OS);
+  ApplyIROptPasses(TheModule);
+  ApplyCodegenPasses(TheModule);
+}
+
 void clang::EmitBackendOutput(DiagnosticsEngine &Diags,
                               const CodeGenOptions &CGOpts,
                               const clang::TargetOptions &TOpts,
@@ -677,3 +735,38 @@
     }
   }
 }
+
+void clang::ApplyIROptimizations(DiagnosticsEngine &Diags,
+                                 const CodeGenOptions &CGOpts,
+                                 const clang::TargetOptions &TOpts,
+                                 const LangOptions &LOpts, Module *M,
+                                 BackendAction Action, raw_pwrite_stream *OS) {
+  EmitAssemblyHelper AsmHelper(Diags, CGOpts, TOpts, LOpts, M);
+  AsmHelper.SetupAssemblyHelper(Action, OS);
+  AsmHelper.ApplyIROptPasses(M);
+}
+
+void clang::CodegenBackendOutput(DiagnosticsEngine &Diags,
+                                 const CodeGenOptions &CGOpts,
+                                 const clang::TargetOptions &TOpts,
+                                 const LangOptions &LOpts, StringRef TDesc,
+                                 Module *M, BackendAction Action,
+                                 raw_pwrite_stream *OS) {
+  EmitAssemblyHelper AsmHelper(Diags, CGOpts, TOpts, LOpts, M);
+  AsmHelper.SetupAssemblyHelper(Action, OS);
+
+  // If an optional clang TargetInfo description string was passed in, use it to
+  // verify the LLVM TargetMachine's DataLayout.
+  if (AsmHelper.TM && !TDesc.empty()) {
+    std::string DLDesc =
+        AsmHelper.TM->getDataLayout()->getStringRepresentation();
+    if (DLDesc != TDesc) {
+      unsigned DiagID = Diags.getCustomDiagID(
+          DiagnosticsEngine::Error, "backend data layout '%0' does not match "
+                                    "expected target description '%1'");
+      Diags.Report(DiagID) << DLDesc << TDesc;
+    }
+  }
+
+  AsmHelper.ApplyCodegenPasses(M);
+}
Index: lib/CodeGen/CGStmt.cpp
===================================================================
--- lib/CodeGen/CGStmt.cpp	(revision 320332)
+++ lib/CodeGen/CGStmt.cpp	(working copy)
@@ -2147,6 +2147,69 @@
   }
 }
 
+
+void CodeGenFunction::addOffloaded(const CapturedStmt *S, ValueDecl *L,
+                                   ValueDecl *G) {
+  assert(S && isa<CapturedStmt>(S) && "Invalid captured statement");
+  assert(L && G && "Invalid value declarations");
+  OffloadedLocals[S].emplace_back(L, G);
+}
+
+const CodeGenFunction::OffloadList &
+CodeGenFunction::getOffloaded(const CapturedStmt *S) const {
+  assert(S && isa<CapturedStmt>(S) && "Invalid captured statement");
+  OffloadMap::const_iterator it = OffloadedLocals.find(S);
+  assert((it != OffloadedLocals.end()) && "Captured statement not visited?");
+  return it->second;
+}
+
+VarDecl *CodeGenFunction::CreateOffloadedGlobal(const Stmt &S, const Expr *I) {
+  ASTContext &AST = getContext();
+  DeclContext *TUC = AST.getTranslationUnitDecl();
+  SourceRange SR = S.getSourceRange();
+  IdentifierInfo *II = &AST.Idents.get("distr_omp_" +
+      std::string(CurFn->getName()) + "_" +
+      cast<DeclRefExpr>(I)->getDecl()->getNameAsString());
+  QualType Ty = I->getType();
+  if(Ty.isLocalConstQualified()) Ty.removeLocalConst();
+  TypeSourceInfo *TSI = AST.getTrivialTypeSourceInfo(Ty, SR.getBegin());
+  return VarDecl::Create(AST, TUC, SR.getBegin(), SR.getEnd(),
+                         II, Ty, TSI, clang::SC_Static);
+}
+
+LValue CodeGenFunction::GetVarDeclLValue(const Expr *I, VarDecl *VD) {
+  QualType SrcType = I->getType();
+  if(SrcType.isLocalConstQualified()) SrcType.removeLocalConst();
+  llvm::Type *Ty = CGM.getTypes().ConvertType(SrcType);
+  llvm::Constant *GV = CGM.GetAddrOfGlobalVar(VD, Ty);
+  llvm::GlobalVariable *CastGV = cast<llvm::GlobalVariable>(GV);
+  CastGV->setInitializer(llvm::Constant::getNullValue(Ty));
+  CastGV->setLinkage(llvm::GlobalValue::InternalLinkage);
+  return MakeNaturalAlignAddrLValue(GV, SrcType);
+}
+
+DeclRefExpr *CodeGenFunction::GetDeclRefForOffload(ValueDecl *VD) {
+  ASTContext &AST = getContext();
+  QualType Ty = VD->getType();
+  DeclRefExpr *DRE = DeclRefExpr::Create(AST, NestedNameSpecifierLoc(),
+                                         SourceLocation(), VD, false,
+                                         VD->getSourceRange().getBegin(),
+                                         Ty, VK_LValue);
+  DRE->getDecl()->setIsUsed();
+  return DRE;
+}
+
+void CodeGenFunction::RestoreOffloadedLocals(const CapturedStmt *S) {
+  Expr *Global;
+  const OffloadList &Offloaded = getOffloaded(S);
+  for(auto Pair : Offloaded) {
+    if(Pair.first->getType().isLocalConstQualified()) continue;
+    LValue LocalLV(EmitDeclRefLValue(GetDeclRefForOffload(Pair.first)));
+    Global = GetDeclRefForOffload(Pair.second);
+    EmitAnyExprToMem(Global, LocalLV.getAddress(), LocalLV.getQuals(), false);
+  }
+}
+
 LValue CodeGenFunction::InitCapturedStruct(const CapturedStmt &S) {
   const RecordDecl *RD = S.getCapturedRecordDecl();
   QualType RecordTy = getContext().getRecordType(RD);
@@ -2155,6 +2218,8 @@
   LValue SlotLV = MakeNaturalAlignAddrLValue(
       CreateMemTemp(RecordTy, "agg.captured"), RecordTy);
 
+  if(S.offloadShared()) OffloadedLocals[&S] = OffloadList();
+
   RecordDecl::field_iterator CurField = RD->field_begin();
   for (CapturedStmt::capture_init_iterator I = S.capture_init_begin(),
                                            E = S.capture_init_end();
@@ -2164,7 +2229,18 @@
       auto VAT = CurField->getCapturedVLAType();
       EmitStoreThroughLValue(RValue::get(VLASizeMap[VAT->getSizeExpr()]), LV);
     } else {
-      EmitInitializerForField(*CurField, LV, *I, None);
+      if(S.offloadShared()) {
+        // If distributed, create global variable, emit initializer & place
+        // address of new global into capture struct
+        assert(isa<DeclRefExpr>(*I) && "Invalid capture type");
+        VarDecl *GLD = CreateOffloadedGlobal(S, *I);
+        LValue GLV = GetVarDeclLValue(*I, GLD);
+        EmitAnyExprToMem(*I, GLV.getAddress(), GLV.getQuals(), false);
+        Expr *GlobalRef = GetDeclRefForOffload(GLD);
+        EmitInitializerForField(*CurField, LV, GlobalRef, None);
+        addOffloaded(&S, cast<DeclRefExpr>(*I)->getDecl(), GLD);
+      }
+      else EmitInitializerForField(*CurField, LV, *I, None);
     }
   }
 
Index: lib/CodeGen/CGStmtOpenMP.cpp
===================================================================
--- lib/CodeGen/CGStmtOpenMP.cpp	(revision 320332)
+++ lib/CodeGen/CGStmtOpenMP.cpp	(working copy)
@@ -17,6 +17,7 @@
 #include "TargetInfo.h"
 #include "clang/AST/Stmt.h"
 #include "clang/AST/StmtOpenMP.h"
+#include "llvm/IR/CallSite.h"
 using namespace clang;
 using namespace CodeGen;
 
@@ -489,6 +490,8 @@
   }
   CGF.CGM.getOpenMPRuntime().emitParallelCall(CGF, S.getLocStart(), OutlinedFn,
                                               CapturedStruct, IfCond);
+
+  if(CS->offloadShared()) CGF.RestoreOffloadedLocals(CS);
 }
 
 void CodeGenFunction::EmitOMPParallelDirective(const OMPParallelDirective &S) {
@@ -743,6 +746,162 @@
   }
 }
 
+/// Ease the variable lookup burden for captures.
+typedef llvm::DenseMap<const VarDecl *, DeclRefExpr *> CaptureMap;
+
+/// Map variable declarations captured in the outer function to their field in
+/// the captured struct.
+static void
+buildCapturedMap(ASTContext &C, CapturedStmt *CS, CaptureMap &Map) {
+  // Captures are in a 1-to-1 correspondence with captured record fields
+  Map.clear();
+  for(auto Child : CS->children()) {
+    if(isa<DeclRefExpr>(Child)) {
+      DeclRefExpr *DRE = cast<DeclRefExpr>(Child);
+      ValueDecl *Decl = DRE->getDecl();
+      if(isa<VarDecl>(Decl)) Map[cast<VarDecl>(Decl)] = DRE;
+    }
+  }
+}
+
+/// Create an expression representing the address of some array index.
+static Expr *getPrefetchAddr(ASTContext &C, Expr *Ptr, Expr *Subscript) {
+  QualType BaseTy = Ptr->getType().getDesugaredType(C), IdxTy;
+
+  // Get an array subscript
+  if(isa<ArrayType>(BaseTy)) IdxTy = cast<ArrayType>(BaseTy)->getElementType();
+  else IdxTy = cast<PointerType>(BaseTy)->getPointeeType();
+  Expr *Index = new (C) ArraySubscriptExpr(Ptr, Subscript, IdxTy,
+                                           VK_RValue, OK_Ordinary,
+                                           SourceLocation());
+
+  // Take the address of the array subscript
+  QualType RePtrTy = C.getPointerType(IdxTy);
+  UnaryOperator *Addr = new (C) UnaryOperator(Index, UO_AddrOf, RePtrTy, VK_LValue,
+                               OK_Ordinary, SourceLocation());
+
+  // Finally, cast to a const void * type
+  QualType VoidPtrTy = C.getPointerType(C.VoidTy.withConst());
+  return ImplicitCastExpr::Create(C, VoidPtrTy, CK_BitCast, Addr, nullptr,
+                                  VK_RValue);
+}
+
+static Expr *getArrayIndexAddr(ASTContext &C, Expr *Arr, const llvm::APInt &Idx) {
+  QualType Ty = Arr->getType();
+  if(Ty->isArrayType()) {
+    Ty = C.getPointerType(cast<ArrayType>(Ty)->getElementType());
+    Arr = ImplicitCastExpr::Create(C, Ty, CK_ArrayToPointerDecay, Arr, nullptr,
+                                   VK_RValue);
+  }
+  Expr *IdxLiteral =
+    IntegerLiteral::Create(C, Idx, C.LongTy, SourceLocation());
+  return getPrefetchAddr(C, Arr, IdxLiteral);
+}
+
+static Expr *getArrayIndexAddr(ASTContext &C, Expr *Arr, int64_t Idx) {
+  return getArrayIndexAddr(C, Arr, llvm::APInt(64, Idx, true));
+}
+
+static llvm::Constant *getPrefetchKind(CodeGenFunction &CGF,
+                                       OpenMPPrefetchClauseKind Kind) {
+  llvm::Type *Ty = llvm::Type::getInt32Ty(CGF.CurFn->getContext());
+  switch(Kind) {
+  case OMPC_PREFETCH_read: return llvm::ConstantInt::get(Ty, 0);
+  case OMPC_PREFETCH_write: return llvm::ConstantInt::get(Ty, 1);
+  //case OMPC_PREFETCH_release: return llvm::ConstantInt::get(Ty, 3);
+  default:
+    llvm_unreachable("Invalid prefetch type\n");
+    return nullptr;
+  }
+}
+
+void CodeGenFunction::EmitOMPPrefetchClauses(const OMPLoopDirective &D) {
+  ASTContext &AST = getContext();
+  CaptureMap AllCaptures;
+  CaptureMap::iterator Captured;
+  const ConstantArrayType *ArrTy;
+  Expr *Base, *Start, *End, *StartAddr, *EndAddr;
+  RValue LoweredStart, LoweredEnd;
+  std::vector<llvm::Value *> Params;
+  std::vector<llvm::Type *> ParamTypes;
+  llvm::FunctionType *FnType;
+  llvm::Constant *Prefetch, *Execute;
+
+  bool HasPrefetch = !D.getClausesOfKind(OMPC_prefetch).empty();
+  if(HasPrefetch) {
+    // declare void @popcorn_prefetch(i32, i8*, i8*)
+    ParamTypes = { Int32Ty, Int8PtrTy, Int8PtrTy };
+    FnType = llvm::FunctionType::get(VoidTy, ParamTypes, false);
+    Prefetch = CGM.CreateRuntimeFunction(FnType, "popcorn_prefetch");
+
+    // declare i64 @popcorn_prefetch_execute()
+    ParamTypes.clear();
+    FnType = llvm::FunctionType::get(Int64Ty, ParamTypes, false);
+    Execute = CGM.CreateRuntimeFunction(FnType, "popcorn_prefetch_execute");
+
+    // For each prefetched variable, construct start & end range expressions
+    // and call @popcorn_prefetch
+    CapturedStmt *CS = cast<CapturedStmt>(D.getAssociatedStmt());
+    buildCapturedMap(AST, CS, AllCaptures);
+
+    for(auto &&I = D.getClausesOfKind(OMPC_prefetch); I; ++I) {
+      auto *C = cast<OMPPrefetchClause>(*I);
+      Start = C->getStartOfRange();
+      End = C->getEndOfRange();
+
+      for(auto &V : C->varlists()) {
+        const DeclRefExpr *DR = cast<DeclRefExpr>(V);
+        const VarDecl *VD = cast<VarDecl>(DR->getDecl());
+        Captured = AllCaptures.find(VD);
+
+        // TODO the current mechanism for calculating addresses applies an
+        // "inbounds" tag to the array index addressing expression, but we
+        // don't necessarily know this is true.
+        if(Captured != AllCaptures.end()) {
+          Base = Captured->second;
+          if(Start && End) {
+            // User specified entire range
+            StartAddr = getPrefetchAddr(AST, Base, Start);
+            EndAddr = getPrefetchAddr(AST, Base, End);
+          }
+          else if(Start) {
+            // User specified an expression affine to loop iteration variable
+            // TODO if expression is affine transformation of loop induction
+            // variable, need to re-generate for lower/upper bound variables
+            assert(isa<DeclRefExpr>(Start) &&
+                   "Can't handle transformations on loop variables yet");
+            StartAddr = getPrefetchAddr(AST, Base, D.getLowerBoundVariable());
+            EndAddr = getPrefetchAddr(AST, Base, D.getUpperBoundVariable());
+          }
+          else {
+            // User didn't specify a range, prefetch the entire array (note:
+            // should have type checked it's an array by now).
+            QualType QTy = Base->getType();
+            while(isa<DecayedType>(QTy))
+              QTy = cast<DecayedType>(QTy)->getOriginalType();
+            ArrTy = cast<ConstantArrayType>(QTy);
+            const llvm::APInt &Size = ArrTy->getSize();
+            StartAddr = getArrayIndexAddr(AST, Base, 0);
+            EndAddr = getArrayIndexAddr(AST, Base, Size);
+          }
+
+          LoweredStart = EmitAnyExpr(StartAddr);
+          LoweredEnd = EmitAnyExpr(EndAddr);
+          Params = { getPrefetchKind(*this, C->getPrefetchKind()),
+                     LoweredStart.getScalarVal(),
+                     LoweredEnd.getScalarVal() };
+          EmitCallOrInvoke(Prefetch, Params);
+        }
+        else llvm_unreachable("Invalid prefetch variable");
+      }
+    }
+
+    // Finally, call @popcorn_prefetch_execute to issue requests
+    Params.clear();
+    EmitCallOrInvoke(Execute, Params);
+  }
+}
+
 void CodeGenFunction::EmitOMPSimdInit(const OMPLoopDirective &D) {
   // Walk clauses and process safelen/lastprivate.
   LoopStack.setParallel();
@@ -1137,6 +1296,8 @@
         auto LoopExit = getJumpDestInCurrentScope(createBasicBlock("omp.loop.exit"));
         // UB = min(UB, GlobalUB);
         EmitIgnoredExpr(S.getEnsureUpperBound());
+        // Popcorn: emit prefetch function declarations & requests
+        if(S.prefetchingEnabled()) EmitOMPPrefetchClauses(S);
         // IV = LB;
         EmitIgnoredExpr(S.getInit());
         // while (idx <= UB) { BODY; ++idx; }
@@ -2049,6 +2210,7 @@
   case OMPC_threadprivate:
   case OMPC_depend:
   case OMPC_mergeable:
+  case OMPC_prefetch:
     llvm_unreachable("Clause is not allowed in 'omp atomic'.");
   }
 }
Index: lib/CodeGen/CMakeLists.txt
===================================================================
--- lib/CodeGen/CMakeLists.txt	(revision 320332)
+++ lib/CodeGen/CMakeLists.txt	(working copy)
@@ -73,6 +73,7 @@
   MicrosoftCXXABI.cpp
   ModuleBuilder.cpp
   ObjectFilePCHContainerOperations.cpp
+  PopcornUtil.cpp
   SanitizerMetadata.cpp
   TargetInfo.cpp
 
Index: lib/CodeGen/CodeGenAction.cpp
===================================================================
--- lib/CodeGen/CodeGenAction.cpp	(revision 320332)
+++ lib/CodeGen/CodeGenAction.cpp	(working copy)
@@ -18,6 +18,7 @@
 #include "clang/CodeGen/BackendUtil.h"
 #include "clang/CodeGen/CodeGenAction.h"
 #include "clang/CodeGen/ModuleBuilder.h"
+#include "clang/CodeGen/PopcornUtil.h"
 #include "clang/Frontend/CompilerInstance.h"
 #include "clang/Frontend/FrontendDiagnostic.h"
 #include "clang/Lex/Preprocessor.h"
@@ -34,6 +35,7 @@
 #include "llvm/Support/MemoryBuffer.h"
 #include "llvm/Support/SourceMgr.h"
 #include "llvm/Support/Timer.h"
+#include "llvm/Transforms/Utils/Cloning.h"
 #include <memory>
 using namespace clang;
 using namespace llvm;
@@ -41,6 +43,7 @@
 namespace clang {
   class BackendConsumer : public ASTConsumer {
     virtual void anchor();
+  protected:
     DiagnosticsEngine &Diags;
     BackendAction Action;
     const CodeGenOptions &CodeGenOpts;
@@ -129,7 +132,7 @@
         LLVMIRGeneration.stopTimer();
     }
 
-    void HandleTranslationUnit(ASTContext &C) override {
+    void HandleTranslationUnitCommon(ASTContext &C) {
       {
         PrettyStackTraceString CrashInfo("Per-file LLVM IR generation");
         if (llvm::TimePassesIsEnabled)
@@ -165,7 +168,11 @@
                 [=](const DiagnosticInfo &DI) { linkerDiagnosticHandler(DI); }))
           return;
       }
+    }
 
+    void HandleTranslationUnit(ASTContext &C) override {
+      HandleTranslationUnitCommon(C);
+
       // Install an inline asm handler so that diagnostics get printed through
       // our diagnostics hooks.
       LLVMContext &Ctx = TheModule->getContext();
@@ -261,6 +268,76 @@
   };
   
   void BackendConsumer::anchor() {}
+
+  class MultiBackendConsumer : public BackendConsumer {
+  private:
+    virtual void anchor() override;
+    SmallVector<raw_pwrite_stream *, 2> &AsmOutStreams;
+    const SmallVector<std::shared_ptr<TargetOptions>, 2> &AsmTargetOpts;
+    const SmallVector<TargetInfo *, 2> &AsmTargetInfos;
+    const CodeGenOptions &NoOptCodegen;
+  public:
+    MultiBackendConsumer(DiagnosticsEngine &Diags,
+                    const HeaderSearchOptions &HeaderSearchOpts,
+                    const PreprocessorOptions &PPOpts,
+                    const CodeGenOptions &CodeGenOpts,
+                    const CodeGenOptions &NoOptCodegen,
+                    const SmallVector<std::shared_ptr<TargetOptions>, 2> &TargetOpts,
+                    const LangOptions &LangOpts, bool TimePasses,
+                    const std::string &InFile, llvm::Module *LinkModule,
+                    SmallVector<raw_pwrite_stream *, 2> &OSs, LLVMContext &C,
+                    const SmallVector<TargetInfo *, 2> &TargetInfos,
+                    CoverageSourceInfo *CoverageInfo = nullptr)
+        : BackendConsumer(Backend_EmitMultiObj, Diags, HeaderSearchOpts,
+                          PPOpts, CodeGenOpts, *TargetOpts[0], LangOpts,
+                          TimePasses, InFile, LinkModule, OSs[0], C,
+                          CoverageInfo),
+          AsmOutStreams(OSs), AsmTargetOpts(TargetOpts),
+          AsmTargetInfos(TargetInfos), NoOptCodegen(NoOptCodegen) {}
+
+    void HandleTranslationUnit(ASTContext &C) override {
+      HandleTranslationUnitCommon(C);
+
+      // Install an inline asm handler so that diagnostics get printed through
+      // our diagnostics hooks.
+      LLVMContext &Ctx = TheModule->getContext();
+      LLVMContext::InlineAsmDiagHandlerTy OldHandler =
+        Ctx.getInlineAsmDiagnosticHandler();
+      void *OldContext = Ctx.getInlineAsmDiagnosticContext();
+      Ctx.setInlineAsmDiagnosticHandler(InlineAsmDiagHandler, this);
+
+      LLVMContext::DiagnosticHandlerTy OldDiagnosticHandler =
+          Ctx.getDiagnosticHandler();
+      void *OldDiagnosticContext = Ctx.getDiagnosticContext();
+      Ctx.setDiagnosticHandler(DiagnosticHandler, this);
+
+      // Apply IR optimizations, but strip target-specific attributes from
+      // all functions added by analyses
+      std::shared_ptr<TargetOptions> IRTargetOpts =
+        Popcorn::GetPopcornTargetOpts(TheModule->getTargetTriple());
+      ApplyIROptimizations(Diags, CodeGenOpts, *IRTargetOpts, LangOpts,
+                           TheModule.get(), Action, nullptr);
+      Popcorn::StripTargetAttributes(*TheModule);
+
+      // Generate machine code for each target
+      for(size_t i = 0; i < AsmTargetOpts.size(); i++) {
+        llvm::Module* ArchModule = CloneModule(TheModule.get());
+        ArchModule->setTargetTriple(AsmTargetInfos[i]->getTriple().getTriple());
+        ArchModule->setDataLayout(AsmTargetInfos[i]->getTargetDescription());
+        Popcorn::AddArchSpecificTargetFeatures(*ArchModule, AsmTargetOpts[i]);
+        CodegenBackendOutput(Diags, NoOptCodegen, *AsmTargetOpts[i], LangOpts,
+                             AsmTargetInfos[i]->getTargetDescription(),
+                             ArchModule, Action, AsmOutStreams[i]);
+        delete ArchModule;
+      }
+
+      Ctx.setInlineAsmDiagnosticHandler(OldHandler, OldContext);
+
+      Ctx.setDiagnosticHandler(OldDiagnosticHandler, OldDiagnosticContext);
+    }
+  };
+
+  void MultiBackendConsumer::anchor() {}
 }
 
 /// ConvertBackendLocation - Convert a location in a temporary llvm::SourceMgr
@@ -626,6 +703,7 @@
   case Backend_EmitMCNull:
     return CI.createNullOutputFile();
   case Backend_EmitObj:
+  case Backend_EmitMultiObj:
     return CI.createDefaultOutputFile(true, InFile, "o");
   }
 
@@ -632,13 +710,7 @@
   llvm_unreachable("Invalid action!");
 }
 
-std::unique_ptr<ASTConsumer>
-CodeGenAction::CreateASTConsumer(CompilerInstance &CI, StringRef InFile) {
-  BackendAction BA = static_cast<BackendAction>(Act);
-  raw_pwrite_stream *OS = GetOutputStream(CI, InFile, BA);
-  if (BA != Backend_EmitNothing && !OS)
-    return nullptr;
-
+llvm::Module *CodeGenAction::getLinkModuleToUse(CompilerInstance &CI) {
   llvm::Module *LinkModuleToUse = LinkModule;
 
   // If we were not given a link module, and the user requested that one be
@@ -662,6 +734,10 @@
     LinkModuleToUse = ModuleOrErr.get().release();
   }
 
+  return LinkModuleToUse;
+}
+
+CoverageSourceInfo *CodeGenAction::getCoverageInfo(CompilerInstance &CI) {
   CoverageSourceInfo *CoverageInfo = nullptr;
   // Add the preprocessor callback only when the coverage mapping is generated.
   if (CI.getCodeGenOpts().CoverageMapping) {
@@ -669,6 +745,19 @@
     CI.getPreprocessor().addPPCallbacks(
                                     std::unique_ptr<PPCallbacks>(CoverageInfo));
   }
+  return CoverageInfo;
+}
+
+std::unique_ptr<ASTConsumer>
+CodeGenAction::CreateASTConsumer(CompilerInstance &CI, StringRef InFile) {
+  BackendAction BA = static_cast<BackendAction>(Act);
+  raw_pwrite_stream *OS = GetOutputStream(CI, InFile, BA);
+  if (BA != Backend_EmitNothing && !OS)
+    return nullptr;
+
+  llvm::Module *LinkModuleToUse = getLinkModuleToUse(CI);
+  CoverageSourceInfo *CoverageInfo = getCoverageInfo(CI);
+
   std::unique_ptr<BackendConsumer> Result(new BackendConsumer(
       BA, CI.getDiagnostics(), CI.getHeaderSearchOpts(),
       CI.getPreprocessorOpts(), CI.getCodeGenOpts(), CI.getTargetOpts(),
@@ -684,6 +773,42 @@
   SM.print(nullptr, llvm::errs());
 }
 
+bool CodeGenAction::ExecuteActionIRCommon(BackendAction &BA,
+                                          CompilerInstance &CI) {
+  bool Invalid;
+  SourceManager &SM = CI.getSourceManager();
+  FileID FID = SM.getMainFileID();
+  llvm::MemoryBuffer *MainFile = SM.getBuffer(FID, &Invalid);
+  if (Invalid)
+    return true;
+
+  llvm::SMDiagnostic Err;
+  TheModule = parseIR(MainFile->getMemBufferRef(), Err, *VMContext);
+  if (!TheModule) {
+    // Translate from the diagnostic info to the SourceManager location if
+    // available.
+    // TODO: Unify this with ConvertBackendLocation()
+    SourceLocation Loc;
+    if (Err.getLineNo() > 0) {
+      assert(Err.getColumnNo() >= 0);
+      Loc = SM.translateFileLineCol(SM.getFileEntryForID(FID),
+                                    Err.getLineNo(), Err.getColumnNo() + 1);
+    }
+
+    // Strip off a leading diagnostic code if there is one.
+    StringRef Msg = Err.getMessage();
+    if (Msg.startswith("error: "))
+      Msg = Msg.substr(7);
+
+    unsigned DiagID =
+        CI.getDiagnostics().getCustomDiagID(DiagnosticsEngine::Error, "%0");
+
+    CI.getDiagnostics().Report(Loc, DiagID) << Msg;
+    return true;
+  }
+  return false;
+}
+
 void CodeGenAction::ExecuteAction() {
   // If this is an IR file, we have to treat it specially.
   if (getCurrentFileKind() == IK_LLVM_IR) {
@@ -693,37 +818,9 @@
     if (BA != Backend_EmitNothing && !OS)
       return;
 
-    bool Invalid;
-    SourceManager &SM = CI.getSourceManager();
-    FileID FID = SM.getMainFileID();
-    llvm::MemoryBuffer *MainFile = SM.getBuffer(FID, &Invalid);
-    if (Invalid)
+    if(ExecuteActionIRCommon(BA, CI))
       return;
 
-    llvm::SMDiagnostic Err;
-    TheModule = parseIR(MainFile->getMemBufferRef(), Err, *VMContext);
-    if (!TheModule) {
-      // Translate from the diagnostic info to the SourceManager location if
-      // available.
-      // TODO: Unify this with ConvertBackendLocation()
-      SourceLocation Loc;
-      if (Err.getLineNo() > 0) {
-        assert(Err.getColumnNo() >= 0);
-        Loc = SM.translateFileLineCol(SM.getFileEntryForID(FID),
-                                      Err.getLineNo(), Err.getColumnNo() + 1);
-      }
-
-      // Strip off a leading diagnostic code if there is one.
-      StringRef Msg = Err.getMessage();
-      if (Msg.startswith("error: "))
-        Msg = Msg.substr(7);
-
-      unsigned DiagID =
-          CI.getDiagnostics().getCustomDiagID(DiagnosticsEngine::Error, "%0");
-
-      CI.getDiagnostics().Report(Loc, DiagID) << Msg;
-      return;
-    }
     const TargetOptions &TargetOpts = CI.getTargetOpts();
     if (TheModule->getTargetTriple() != TargetOpts.Triple) {
       CI.getDiagnostics().Report(SourceLocation(),
@@ -769,3 +866,140 @@
 void EmitObjAction::anchor() { }
 EmitObjAction::EmitObjAction(llvm::LLVMContext *_VMContext)
   : CodeGenAction(Backend_EmitObj, _VMContext) {}
+
+void EmitMultiObjAction::anchor() { }
+EmitMultiObjAction::EmitMultiObjAction(llvm::LLVMContext *_VMContext)
+  : CodeGenAction(Backend_EmitMultiObj, _VMContext) {}
+
+static std::string AppendArchName(StringRef File, const TargetInfo *TI) {
+  size_t dot = File.rfind('.');
+  std::string NewFile = File.substr(0, dot);
+  NewFile += "_";
+  NewFile += TI->getTriple().getArchName();
+  NewFile += File.substr(dot, StringRef::npos);
+  return NewFile;
+}
+
+/// Create target information & output streams for each target.
+bool EmitMultiObjAction::InitializeTargets(CompilerInstance &CI,
+                                           StringRef InFile) {
+  // Note: remove output filename from frontend args, as it will override any
+  // special names we try to specify.
+  std::string OutFile(InFile);
+  if(CI.getFrontendOpts().OutputFile != "") {
+    OutFile = CI.getFrontendOpts().OutputFile;
+    CI.getFrontendOpts().OutputFile = "";
+  }
+
+  // Populate list of targets requested.  If none are requested, default to all
+  // supported targets.
+  std::vector<std::string> &Requested = CI.getCodeGenOpts().PopcornTargets;
+  if(Requested.size()) {
+    for(auto &Target : Requested) {
+      if(!Popcorn::SupportedTarget(Target)) {
+        std::string Msg("Popcorn: unsupported target '" + Target + "'");
+        unsigned DiagID =
+            CI.getDiagnostics().getCustomDiagID(DiagnosticsEngine::Error, "%0");
+        CI.getDiagnostics().Report(DiagID) << Msg;
+        return false;
+      }
+      Targets.push_back(Target);
+    }
+  }
+  else Popcorn::GetAllTargets(this->Targets);
+
+  BackendAction BA = Backend_EmitMultiObj;
+  if(Targets.size() > 1) {
+    for(size_t i = 0; i < Targets.size(); i++) {
+      std::shared_ptr<TargetOptions> Opts = Popcorn::GetPopcornTargetOpts(Targets[i]);
+      TargetOpts.push_back(Opts);
+      TargetInfos.push_back(TargetInfo::CreateTargetInfo(CI.getDiagnostics(), Opts));
+
+      raw_pwrite_stream *OS;
+      OS = GetOutputStream(CI, AppendArchName(OutFile, TargetInfos[i]), BA);
+      if (!OS) return false;
+      OutFiles.push_back(OS);
+    }
+  }
+  else {
+    std::shared_ptr<TargetOptions> Opts = Popcorn::GetPopcornTargetOpts(Targets[0]);
+    TargetOpts.push_back(Opts);
+    TargetInfos.push_back(TargetInfo::CreateTargetInfo(CI.getDiagnostics(), Opts));
+
+    raw_pwrite_stream *OS = GetOutputStream(CI, OutFile, BA);
+    if (!OS) return false;
+    OutFiles.push_back(OS);
+  }
+  CI.getFrontendOpts().OutputFile = OutFile;
+
+  return true;
+}
+
+/// Initialize target information & open output streams for each target.
+std::unique_ptr<ASTConsumer>
+EmitMultiObjAction::CreateASTConsumer(CompilerInstance &CI,
+                                      StringRef InFile) {
+  if(!InitializeTargets(CI, InFile)) return nullptr;
+  llvm::Module *LinkModuleToUse = getLinkModuleToUse(CI);
+  CoverageSourceInfo *CoverageInfo = getCoverageInfo(CI);
+
+  // Create a MultiBackendConsumer, which is identical to a BackendConsumer
+  // except that it runs the generated IR through multiple backends.
+  std::unique_ptr<MultiBackendConsumer> Result(new MultiBackendConsumer(
+      CI.getDiagnostics(), CI.getHeaderSearchOpts(),
+      CI.getPreprocessorOpts(), CI.getCodeGenOpts(), CI.getCodeGenNoOpts(),
+      TargetOpts, CI.getLangOpts(), CI.getFrontendOpts().ShowTimers, InFile,
+      LinkModuleToUse, OutFiles, *VMContext, TargetInfos, CoverageInfo));
+  BEConsumer = Result.get();
+  return std::move(Result);
+}
+
+void EmitMultiObjAction::ExecuteAction() {
+  // If this is an IR file, we have to treat it specially.
+  if (getCurrentFileKind() == IK_LLVM_IR) {
+    // Initialize targets here because we never called CreateASTConsumer
+    CompilerInstance &CI = getCompilerInstance();
+    StringRef OutFile = getCurrentFile();
+    BackendAction BA = Backend_EmitMultiObj;
+
+    if(!InitializeTargets(CI, OutFile)) {
+      // TODO add diagnostics saying we couldn't initialize targets
+      return;
+    }
+
+    if(ExecuteActionIRCommon(BA, CI)) {
+      // TODO add diagnostics saying we couldn't do common IR work
+      return;
+    }
+
+    // Apply IR optimizations, but strip target-specific attributes from all
+    // functions added by analyses
+    std::shared_ptr<TargetOptions> IRTargetOpts =
+      Popcorn::GetPopcornTargetOpts(TheModule->getTargetTriple());
+    ApplyIROptimizations(CI.getDiagnostics(), CI.getCodeGenOpts(),
+                         *IRTargetOpts, CI.getLangOpts(),
+                         TheModule.get(), BA, nullptr);
+    Popcorn::StripTargetAttributes(*TheModule);
+
+    // Emit machine code for all specified architectures
+    for(size_t i = 0; i < Targets.size(); i++) {
+      llvm::Module *ArchModule = CloneModule(TheModule.get());
+      ArchModule->setTargetTriple(Targets[i]);
+      ArchModule->setDataLayout(TargetInfos[i]->getTargetDescription());
+      Popcorn::AddArchSpecificTargetFeatures(*ArchModule, TargetOpts[i]);
+      LLVMContext &Ctx = ArchModule->getContext();
+      Ctx.setInlineAsmDiagnosticHandler(BitcodeInlineAsmDiagHandler);
+      CodegenBackendOutput(CI.getDiagnostics(), CI.getCodeGenNoOpts(),
+                           *TargetOpts[i], CI.getLangOpts(),
+                           TargetInfos[i]->getTargetDescription(),
+                           ArchModule, BA, OutFiles[i]);
+      delete ArchModule;
+    }
+
+    return;
+  }
+
+  // Otherwise follow the normal AST path.
+  this->ASTFrontendAction::ExecuteAction();
+}
+
Index: lib/CodeGen/CodeGenFunction.h
===================================================================
--- lib/CodeGen/CodeGenFunction.h	(revision 320332)
+++ lib/CodeGen/CodeGenFunction.h	(working copy)
@@ -913,6 +913,15 @@
   llvm::MDNode *createProfileWeightsForLoop(const Stmt *Cond,
                                             uint64_t LoopCount);
 
+  /// \brief Locals that were offloaded to global memory for a captured
+  /// statement and need to be restored after the statement has executed.
+  /// First declaration in the pair is the local, second is the global.
+  /// Maintain a mapping of captured statements & their offloaded locals.
+  typedef std::pair<ValueDecl *, ValueDecl *> OffloadPair;
+  typedef llvm::SmallVector<OffloadPair, 4> OffloadList;
+  typedef llvm::DenseMap<const CapturedStmt *, OffloadList> OffloadMap;
+  OffloadMap OffloadedLocals;
+
 public:
   /// Increment the profiler's counter for the given statement.
   void incrementProfileCounter(const Stmt *S) {
@@ -2084,6 +2093,15 @@
   void EmitCXXForRangeStmt(const CXXForRangeStmt &S,
                            ArrayRef<const Attr *> Attrs = None);
 
+  /// \brief Offload/restore capabilities for local variables captured in
+  /// capture statements.
+  void addOffloaded(const CapturedStmt *S, ValueDecl *L, ValueDecl *G);
+  const OffloadList &getOffloaded(const CapturedStmt *S) const;
+  VarDecl *CreateOffloadedGlobal(const Stmt &S, const Expr *I);
+  LValue GetVarDeclLValue(const Expr *I, VarDecl *VD);
+  DeclRefExpr *GetDeclRefForOffload(ValueDecl *VD);
+  void RestoreOffloadedLocals(const CapturedStmt *S);
+
   LValue InitCapturedStruct(const CapturedStmt &S);
   llvm::Function *EmitCapturedStmt(const CapturedStmt &S, CapturedRegionKind K);
   void GenerateCapturedStmtFunctionProlog(const CapturedStmt &S);
@@ -2191,6 +2209,10 @@
   ///
   /// \param D Directive (possibly) with the 'linear' clause.
   void EmitOMPLinearClauseInit(const OMPLoopDirective &D);
+  /// \brief Emit prefetching requests for loop directive.
+  ///
+  /// \param D Directive (possibly) with the 'prefetch' clause.
+  void EmitOMPPrefetchClauses(const OMPLoopDirective &D);
 
   void EmitOMPParallelDirective(const OMPParallelDirective &S);
   void EmitOMPSimdDirective(const OMPSimdDirective &S);
Index: lib/CodeGen/PopcornUtil.cpp
===================================================================
--- lib/CodeGen/PopcornUtil.cpp	(nonexistent)
+++ lib/CodeGen/PopcornUtil.cpp	(working copy)
@@ -0,0 +1,103 @@
+//===--- PopcornUtil.cpp - LLVM Popcorn Linux Utilities -------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include <clang/CodeGen/PopcornUtil.h>
+#include <llvm/ADT/Triple.h>
+#include <llvm/ADT/SmallVector.h>
+
+using namespace clang;
+using namespace llvm;
+
+const static std::vector<std::string> PopcornSupported = {
+  "aarch64-linux-gnu",
+  "x86_64-linux-gnu"
+};
+
+bool Popcorn::SupportedTarget(const StringRef Target) {
+  for(auto SupportedTarget : PopcornSupported)
+    if(Target == SupportedTarget) return true;
+  return false;
+}
+
+void Popcorn::GetAllTargets(SmallVector<std::string, 2> &Targets) {
+  Targets.clear();
+  for(auto Target : PopcornSupported) Targets.push_back(Target);
+}
+
+typedef std::shared_ptr<TargetOptions> TargetOptionsPtr;
+
+TargetOptionsPtr Popcorn::GetPopcornTargetOpts(const StringRef TripleStr) {
+  Triple Triple(Triple::normalize(TripleStr));
+  assert(!Triple.getTriple().empty() && "Invalid target triple");
+
+  TargetOptionsPtr Opts(new TargetOptions);
+  Opts->Triple = Triple.getTriple();
+  Opts->ABI = "";
+  Opts->FPMath = "";
+  Opts->FeaturesAsWritten.clear();
+  Opts->LinkerVersion = "";
+  Opts->Reciprocals.clear();
+
+  // TODO need to make CPU selectable & add target features according to CPU
+
+  switch(Triple.getArch()) {
+  case Triple::ArchType::aarch64:
+    Opts->ABI = "aapcs";
+    Opts->CPU = "generic";
+    Opts->FeaturesAsWritten.push_back("+neon");
+    break;
+  case Triple::ArchType::x86_64:
+    Opts->CPU = "x86-64";
+    Opts->FPMath = "sse";
+    Opts->FeaturesAsWritten.push_back("+sse");
+    Opts->FeaturesAsWritten.push_back("+sse2");
+    Opts->FeaturesAsWritten.push_back("+rtm");
+    break;
+  default: llvm_unreachable("Triple not currently supported on Popcorn");
+  }
+
+  return Opts;
+}
+
+void Popcorn::StripTargetAttributes(Module &M) {
+  /// Target-specific function attributes
+  static SmallVector<std::string, 2> TargetAttributes = {
+    "target-cpu",
+    "target-features"
+  };
+
+  for(Function &F : M) {
+    AttrBuilder AB(F.getAttributes(), AttributeSet::FunctionIndex);
+    for(std::string &Attr : TargetAttributes) {
+      if(F.hasFnAttribute(Attr))
+        AB.removeAttribute(Attr);
+    }
+    F.setAttributes(
+      AttributeSet::get(F.getContext(), AttributeSet::FunctionIndex, AB));
+  }
+}
+
+void Popcorn::AddArchSpecificTargetFeatures(Module &M,
+                                            TargetOptionsPtr TargetOpts) {
+  static const char *TF = "target-features";
+  std::string AllFeatures("");
+
+  for(auto &Feature : TargetOpts->FeaturesAsWritten)
+    AllFeatures += Feature + ",";
+  AllFeatures = AllFeatures.substr(0, AllFeatures.length() - 1);
+
+  for(Function &F : M) {
+    AttrBuilder AB(F.getAttributes(), AttributeSet::FunctionIndex);
+    assert(!F.hasFnAttribute(TF) && "Target features weren't stripped");
+    AB.addAttribute(TF, AllFeatures);
+    F.setAttributes(
+      AttributeSet::get(F.getContext(), AttributeSet::FunctionIndex, AB));
+  }
+}
+
Index: lib/Driver/Tools.cpp
===================================================================
--- lib/Driver/Tools.cpp	(revision 320332)
+++ lib/Driver/Tools.cpp	(working copy)
@@ -4934,6 +4934,49 @@
       A->render(Args, CmdArgs);
   }
 
+  // Forward Popcorn & other standard compiler flags to -cc1 to generate
+  // multi-ISA binaries
+  if(Args.hasArg(options::OPT_popcorn_migratable) ||
+     Args.hasArg(options::OPT_popcorn_metadata)) {
+    // Full-blown Popcorn migration capabilities, including adding migration
+    // points, symbol alignment and generating stack transformation metadata
+    CmdArgs.push_back("-ffunction-sections");
+    CmdArgs.push_back("-fdata-sections");
+    CmdArgs.push_back("-popcorn-alignment");
+    CmdArgs.push_back("-popcorn-migratable");
+    CmdArgs.push_back("-mllvm");
+    if(Args.hasArg(options::OPT_popcorn_migratable))
+      CmdArgs.push_back("-popcorn-instrument=migration");
+    else
+      CmdArgs.push_back("-popcorn-instrument=metadata");
+    CmdArgs.push_back("-mllvm");
+    CmdArgs.push_back("-optimize-regalloc");
+    CmdArgs.push_back("-mllvm");
+    CmdArgs.push_back("-fast-isel=false");
+    for(auto Target : Args.getAllArgValues(options::OPT_popcorn_target)) {
+      std::string combined("-popcorn-target=" + Target);
+      CmdArgs.push_back(Args.MakeArgString(combined));
+    }
+  }
+  else if(Args.hasArg(options::OPT_popcorn_libc)) {
+    // Symbol alignment for libc & generate stack transformation metadata for
+    // libc thread start functions
+    CmdArgs.push_back("-ffunction-sections");
+    CmdArgs.push_back("-fdata-sections");
+    CmdArgs.push_back("-popcorn-alignment");
+    CmdArgs.push_back("-mllvm");
+    CmdArgs.push_back("-popcorn-instrument=libc");
+  }
+  else if(Args.hasArg(options::OPT_popcorn_alignment)) {
+    // Only symbol alignment
+    CmdArgs.push_back("-ffunction-sections");
+    CmdArgs.push_back("-fdata-sections");
+    CmdArgs.push_back("-popcorn-alignment");
+  }
+
+  if(Args.hasArg(options::OPT_distributed_omp))
+    CmdArgs.push_back("-distributed-omp");
+
   // With -save-temps, we want to save the unoptimized bitcode output from the
   // CompileJobAction, so disable optimizations if they are not already
   // disabled.
Index: lib/Frontend/CompilerInvocation.cpp
===================================================================
--- lib/Frontend/CompilerInvocation.cpp	(revision 320332)
+++ lib/Frontend/CompilerInvocation.cpp	(working copy)
@@ -358,22 +358,11 @@
 
 static bool ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args, InputKind IK,
                              DiagnosticsEngine &Diags,
-                             const TargetOptions &TargetOpts) {
+                             const TargetOptions &TargetOpts,
+                             unsigned OptimizationLevel) {
   using namespace options;
   bool Success = true;
 
-  unsigned OptimizationLevel = getOptimizationLevel(Args, IK, Diags);
-  // TODO: This could be done in Driver
-  unsigned MaxOptLevel = 3;
-  if (OptimizationLevel > MaxOptLevel) {
-    // If the optimization level is not supported, fall back on the default
-    // optimization
-    Diags.Report(diag::warn_drv_optimization_value)
-        << Args.getLastArg(OPT_O)->getAsString(Args) << "-O" << MaxOptLevel;
-    OptimizationLevel = MaxOptLevel;
-  }
-  Opts.OptimizationLevel = OptimizationLevel;
-
   // We must always run at least the always inlining pass.
   Opts.setInlining(
     (Opts.OptimizationLevel > 1) ? CodeGenOptions::NormalInlining
@@ -675,9 +664,41 @@
   Opts.CudaGpuBinaryFileNames =
       Args.getAllArgValues(OPT_fcuda_include_gpubinary);
 
+  Opts.PopcornAlignment = Args.hasArg(OPT_popcorn_alignment);
+  Opts.PopcornMigratable = Args.hasArg(OPT_popcorn_migratable);
+
+  // TODO: the Popcorn compiler doesn't currently support vectorization
+  if(Opts.PopcornMigratable || Args.hasArg(OPT_popcorn_libc)) {
+    Opts.VectorizeBB = 0;
+    Opts.VectorizeLoop = 0;
+    Opts.VectorizeSLP = 0;
+  }
+
+  if(Opts.PopcornMigratable)
+    for(auto Target : Args.getAllArgValues(OPT_popcorn_target))
+      Opts.PopcornTargets.push_back(Target);
+
   return Success;
 }
 
+static bool ParseCodeGenArgs(CodeGenOptions &Opts, ArgList &Args, InputKind IK,
+                             DiagnosticsEngine &Diags,
+                             const TargetOptions &TargetOpts) {
+  unsigned OptimizationLevel = getOptimizationLevel(Args, IK, Diags);
+  // TODO: This could be done in Driver
+  unsigned MaxOptLevel = 3;
+  if (OptimizationLevel > MaxOptLevel) {
+    // If the optimization level is not supported, fall back on the default
+    // optimization
+    Diags.Report(diag::warn_drv_optimization_value)
+        << Args.getLastArg(OPT_O)->getAsString(Args) << "-O" << MaxOptLevel;
+    OptimizationLevel = MaxOptLevel;
+  }
+  Opts.OptimizationLevel = OptimizationLevel;
+  return ParseCodeGenArgs(Opts, Args, IK, Diags, TargetOpts,
+                          OptimizationLevel);
+}
+
 static void ParseDependencyOutputArgs(DependencyOutputOptions &Opts,
                                       ArgList &Args) {
   using namespace options;
@@ -856,7 +877,11 @@
     case OPT_emit_codegen_only:
       Opts.ProgramAction = frontend::EmitCodeGenOnly; break;
     case OPT_emit_obj:
-      Opts.ProgramAction = frontend::EmitObj; break;
+      if(Args.hasArg(OPT_popcorn_migratable))
+        Opts.ProgramAction = frontend::EmitMultiObj;
+      else
+        Opts.ProgramAction = frontend::EmitObj;
+      break;
     case OPT_fixit_EQ:
       Opts.FixItSuffix = A->getValue();
       // fall-through!
@@ -1704,6 +1729,8 @@
   Opts.SanitizeAddressFieldPadding =
       getLastArgIntValue(Args, OPT_fsanitize_address_field_padding, 0, Diags);
   Opts.SanitizerBlacklistFiles = Args.getAllArgValues(OPT_fsanitize_blacklist);
+
+  Opts.DistributedOmp = Args.hasArg(OPT_distributed_omp);
 }
 
 static void ParsePreprocessorArgs(PreprocessorOptions &Opts, ArgList &Args,
@@ -1803,6 +1830,7 @@
   case frontend::EmitLLVMOnly:
   case frontend::EmitCodeGenOnly:
   case frontend::EmitObj:
+  case frontend::EmitMultiObj:
   case frontend::FixIt:
   case frontend::GenerateModule:
   case frontend::GeneratePCH:
@@ -1890,6 +1918,11 @@
   ParseTargetArgs(Res.getTargetOpts(), Args);
   Success &= ParseCodeGenArgs(Res.getCodeGenOpts(), Args, DashX, Diags,
                               Res.getTargetOpts());
+  // TODO Popcorn: until we can limit optimizations across migration points, we
+  // need to turn off backend optimizations
+  if(Args.hasArg(OPT_popcorn_migratable))
+    Success &= ParseCodeGenArgs(Res.getCodeGenNoOpts(), Args, DashX, Diags,
+                                Res.getTargetOpts(), 0);
   ParseHeaderSearchArgs(Res.getHeaderSearchOpts(), Args);
   if (DashX != IK_AST && DashX != IK_LLVM_IR) {
     ParseLangArgs(*Res.getLangOpts(), Args, DashX, Diags);
Index: lib/FrontendTool/ExecuteCompilerInvocation.cpp
===================================================================
--- lib/FrontendTool/ExecuteCompilerInvocation.cpp	(revision 320332)
+++ lib/FrontendTool/ExecuteCompilerInvocation.cpp	(working copy)
@@ -50,6 +50,7 @@
   case EmitLLVMOnly:           return new EmitLLVMOnlyAction();
   case EmitCodeGenOnly:        return new EmitCodeGenOnlyAction();
   case EmitObj:                return new EmitObjAction();
+  case EmitMultiObj:           return new EmitMultiObjAction();
   case FixIt:                  return new FixItAction();
   case GenerateModule:         return new GenerateModuleAction;
   case GeneratePCH:            return new GeneratePCHAction;
Index: lib/Parse/ParseOpenMP.cpp
===================================================================
--- lib/Parse/ParseOpenMP.cpp	(revision 320332)
+++ lib/Parse/ParseOpenMP.cpp	(working copy)
@@ -14,6 +14,7 @@
 #include "RAIIObjectsForParser.h"
 #include "clang/AST/ASTConsumer.h"
 #include "clang/AST/ASTContext.h"
+#include "clang/AST/RecursiveASTVisitor.h"
 #include "clang/AST/StmtOpenMP.h"
 #include "clang/Parse/ParseDiagnostic.h"
 #include "clang/Parse/Parser.h"
@@ -25,6 +26,82 @@
 // OpenMP declarative directives.
 //===----------------------------------------------------------------------===//
 
+/// \brief Helper class to find variables declared or used in a statement's
+/// sub-tree.
+class VarFinder : public RecursiveASTVisitor<VarFinder> {
+public:
+  void reset() { Variables.clear(); }
+
+  bool VisitDeclRefExpr(DeclRefExpr *D) {
+    ValueDecl *VD = D->getDecl();
+    if(isa<VarDecl>(VD)) Variables.insert(cast<VarDecl>(VD));
+    return true;
+  }
+
+  bool VisitVarDecl(VarDecl *D) { Variables.insert(D); return true; }
+
+  const llvm::SmallPtrSet<const VarDecl *, 2> &
+  getDeclaredOrReferencedVars() const { return Variables; }
+
+private:
+  llvm::SmallPtrSet<const VarDecl *, 2> Variables;
+};
+
+void Parser::CheckOpenMPPrefetchClauses(StmtResult Directive) {
+  VarFinder CapturedVarFinder, LoopVarFinder, UseFinder;
+
+  OMPLoopDirective *D = dyn_cast<OMPLoopDirective>(Directive.get());
+  if(D) {
+    // OpenMP Standard 4.5, Section 2.6:
+    // A loop has canonical loop form if it conforms to the following:
+    //    for (init-expr; test-expr; incr-expr) structured-block
+    //      init-expr     One of the following:
+    //                    var = lb
+    //                    integer-type var = lb
+    //                    random-access-iterator-type var = lb
+    //                    pointer-type var = lb
+    //
+    // Thus we can examine the initialization statement to find the loop
+    // iteration variable.
+    CapturedStmt *Captured = cast<CapturedStmt>(D->getAssociatedStmt());
+    ForStmt *For = cast<ForStmt>(Captured->getCapturedStmt());
+    BinaryOperator *InitExpr = cast<BinaryOperator>(For->getInit());
+
+    // Find captured & loop iteration variables
+    CapturedVarFinder.TraverseStmt(Captured);
+    const llvm::SmallPtrSet<const VarDecl *, 2> &CapturedVars =
+      CapturedVarFinder.getDeclaredOrReferencedVars();
+    LoopVarFinder.TraverseStmt(InitExpr);
+    const llvm::SmallPtrSet<const VarDecl *, 2> &LoopVars =
+      LoopVarFinder.getDeclaredOrReferencedVars();
+
+    for(auto &&I = D->getClausesOfKind(OMPC_prefetch); I; ++I) {
+      auto *C = cast<OMPPrefetchClause>(*I);
+
+      // Verify we're only prefetching captured variables
+      for(auto E : C->varlists()) {
+        UseFinder.reset();
+        // TODO this cast is nasty
+        UseFinder.TraverseStmt((Expr *)E);
+        for(const auto &V : UseFinder.getDeclaredOrReferencedVars())
+          if(!CapturedVars.count(V))
+            Diag(E->getExprLoc(), diag::err_omp_invalid_prefetch_capture);
+      }
+
+      // Verify loop iteration variable use
+      Expr *Start = C->getStartOfRange(), *End = C->getEndOfRange();
+      if(Start && !End) {
+        UseFinder.reset();
+        UseFinder.TraverseStmt(Start);
+
+        for(const auto &V : UseFinder.getDeclaredOrReferencedVars())
+          if(!LoopVars.count(V)) Diag(C->getFirstColonLoc(),
+                                      diag::err_omp_invalid_prefetch_loop_var);
+      }
+    }
+  }
+}
+
 static OpenMPDirectiveKind ParseOpenMPDirectiveKind(Parser &P) {
   // Array of foldings: F[i][0] F[i][1] ===> F[i][2].
   // E.g.: OMPD_for OMPD_simd ===> OMPD_for_simd
@@ -294,6 +371,21 @@
           DKind, DirName, CancelRegion, Clauses, AssociatedStmt.get(), Loc,
           EndLoc);
 
+    // Enable optimizations for Popcorn Linux, if requested.
+    if(PP.getLangOpts().DistributedOmp) {
+      if((DKind == OMPD_parallel || DKind == OMPD_parallel_for ||
+          DKind == OMPD_parallel_for_simd || DKind == OMPD_parallel_sections)) {
+        CapturedStmt *CS = cast<CapturedStmt>(AssociatedStmt.get());
+        CS->setOffloadShared(true);
+      }
+
+      if(DKind == OMPD_for || DKind == OMPD_parallel_for ||
+         DKind == OMPD_parallel_for_simd) {
+        cast<OMPExecutableDirective>(Directive.get())->setPrefetching(true);
+        CheckOpenMPPrefetchClauses(Directive);
+      }
+    }
+
     // Exit scope.
     Actions.EndOpenMPDSABlock(Directive.get());
     OMPDirectiveScope.Exit();
@@ -385,7 +477,7 @@
 ///       lastprivate-clause | reduction-clause | proc_bind-clause |
 ///       schedule-clause | copyin-clause | copyprivate-clause | untied-clause |
 ///       mergeable-clause | flush-clause | read-clause | write-clause |
-///       update-clause | capture-clause | seq_cst-clause
+///       update-clause | capture-clause | seq_cst-clause | prefetch-clause
 ///
 OMPClause *Parser::ParseOpenMPClause(OpenMPDirectiveKind DKind,
                                      OpenMPClauseKind CKind, bool FirstClause) {
@@ -479,6 +571,7 @@
   case OMPC_copyprivate:
   case OMPC_flush:
   case OMPC_depend:
+  case OMPC_prefetch:
     Clause = ParseOpenMPVarListClause(CKind);
     break;
   case OMPC_unknown:
@@ -702,17 +795,20 @@
 ///       'flush' '(' list ')'
 ///    depend-clause:
 ///       'depend' '(' in | out | inout : list ')'
+///    prefetch-clause:
+///       'prefetch' '(' read | write ':' list [ ':' start ':' end ] ')'
 ///
 OMPClause *Parser::ParseOpenMPVarListClause(OpenMPClauseKind Kind) {
   SourceLocation Loc = Tok.getLocation();
   SourceLocation LOpen = ConsumeToken();
-  SourceLocation ColonLoc = SourceLocation();
+  SourceLocation ColonLoc = SourceLocation(), EndColonLoc = SourceLocation();
   // Optional scope specifier and unqualified id for reduction identifier.
   CXXScopeSpec ReductionIdScopeSpec;
   UnqualifiedId ReductionId;
   bool InvalidReductionId = false;
   OpenMPDependClauseKind DepKind = OMPC_DEPEND_unknown;
-  SourceLocation DepLoc;
+  OpenMPPrefetchClauseKind PrefKind = OMPC_PREFETCH_unknown;
+  SourceLocation DepLoc, PrefLoc;
 
   // Parse '('.
   BalancedDelimiterTracker T(*this, tok::l_paren, tok::annot_pragma_openmp_end);
@@ -755,6 +851,20 @@
     } else {
       Diag(Tok, diag::warn_pragma_expected_colon) << "dependency type";
     }
+  } else if (Kind == OMPC_prefetch) {
+  // Handle permission type for prefetch clause.
+    ColonProtectionRAIIObject ColonRAII(*this);
+    PrefKind = static_cast<OpenMPPrefetchClauseKind>(getOpenMPSimpleClauseType(
+        Kind, Tok.is(tok::identifier) ? PP.getSpelling(Tok) : ""));
+    PrefLoc = Tok.getLocation();
+
+    if (PrefKind == OMPC_PREFETCH_unknown) {
+      SkipUntil(tok::r_paren, tok::annot_pragma_openmp_end, StopBeforeMatch);
+      Diag(PrefLoc, diag::err_omp_invalid_prefetch_kind) << true;
+    } else {
+      ConsumeToken(); // Keyword
+      ConsumeToken(); // Colon
+    }
   }
 
   SmallVector<Expr *, 5> Vars;
@@ -761,7 +871,8 @@
   bool IsComma = ((Kind != OMPC_reduction) && (Kind != OMPC_depend)) ||
                  ((Kind == OMPC_reduction) && !InvalidReductionId) ||
                  ((Kind == OMPC_depend) && DepKind != OMPC_DEPEND_unknown);
-  const bool MayHaveTail = (Kind == OMPC_linear || Kind == OMPC_aligned);
+  const bool MayHaveTail = (Kind == OMPC_linear || Kind == OMPC_aligned ||
+                            Kind == OMPC_prefetch);
   while (IsComma || (Tok.isNot(tok::r_paren) && Tok.isNot(tok::colon) &&
                      Tok.isNot(tok::annot_pragma_openmp_end))) {
     ColonProtectionRAIIObject ColonRAII(*this, MayHaveTail);
@@ -787,9 +898,9 @@
           << (Kind == OMPC_flush);
   }
 
-  // Parse ':' linear-step (or ':' alignment).
+  // Parse ':' linear-step, ':' alignment, or ':' start.
   Expr *TailExpr = nullptr;
-  const bool MustHaveTail = MayHaveTail && Tok.is(tok::colon);
+  const bool MustHaveTail = (MayHaveTail && Tok.is(tok::colon));
   if (MustHaveTail) {
     ColonLoc = Tok.getLocation();
     ConsumeToken();
@@ -802,6 +913,20 @@
                 StopBeforeMatch);
   }
 
+  // Parse ':' end.
+  Expr *EndExpr = nullptr;
+  if (Kind == OMPC_prefetch && Tok.is(tok::colon)) {
+    EndColonLoc = Tok.getLocation();
+    ConsumeToken();
+    ExprResult Tail =
+        Actions.CorrectDelayedTyposInExpr(ParseAssignmentExpression());
+    if (Tail.isUsable())
+      EndExpr = Tail.get();
+    else
+      SkipUntil(tok::comma, tok::r_paren, tok::annot_pragma_openmp_end,
+                StopBeforeMatch);
+  }
+
   // Parse ')'.
   T.consumeClose();
   if ((Kind == OMPC_depend && DepKind != OMPC_DEPEND_unknown && Vars.empty()) ||
@@ -810,10 +935,10 @@
     return nullptr;
 
   return Actions.ActOnOpenMPVarListClause(
-      Kind, Vars, TailExpr, Loc, LOpen, ColonLoc, Tok.getLocation(),
-      ReductionIdScopeSpec,
+      Kind, Vars, TailExpr, EndExpr, Loc, LOpen, ColonLoc, EndColonLoc,
+      Tok.getLocation(), ReductionIdScopeSpec,
       ReductionId.isValid() ? Actions.GetNameFromUnqualifiedId(ReductionId)
                             : DeclarationNameInfo(),
-      DepKind, DepLoc);
+      DepKind, DepLoc, PrefKind, PrefLoc);
 }
 
Index: lib/Sema/SemaOpenMP.cpp
===================================================================
--- lib/Sema/SemaOpenMP.cpp	(revision 320332)
+++ lib/Sema/SemaOpenMP.cpp	(working copy)
@@ -4616,6 +4616,7 @@
   case OMPC_seq_cst:
   case OMPC_depend:
   case OMPC_unknown:
+  case OMPC_prefetch:
     llvm_unreachable("Clause is not allowed.");
   }
   return Res;
@@ -4831,6 +4832,7 @@
   case OMPC_seq_cst:
   case OMPC_depend:
   case OMPC_unknown:
+  case OMPC_prefetch:
     llvm_unreachable("Clause is not allowed.");
   }
   return Res;
@@ -4952,6 +4954,7 @@
   case OMPC_seq_cst:
   case OMPC_depend:
   case OMPC_unknown:
+  case OMPC_prefetch:
     llvm_unreachable("Clause is not allowed.");
   }
   return Res;
@@ -5075,6 +5078,7 @@
   case OMPC_flush:
   case OMPC_depend:
   case OMPC_unknown:
+  case OMPC_prefetch:
     llvm_unreachable("Clause is not allowed.");
   }
   return Res;
@@ -5129,10 +5133,12 @@
 
 OMPClause *Sema::ActOnOpenMPVarListClause(
     OpenMPClauseKind Kind, ArrayRef<Expr *> VarList, Expr *TailExpr,
-    SourceLocation StartLoc, SourceLocation LParenLoc, SourceLocation ColonLoc,
+    Expr *EndExpr, SourceLocation StartLoc, SourceLocation LParenLoc,
+    SourceLocation ColonLoc, SourceLocation EndColonLoc,
     SourceLocation EndLoc, CXXScopeSpec &ReductionIdScopeSpec,
     const DeclarationNameInfo &ReductionId, OpenMPDependClauseKind DepKind,
-    SourceLocation DepLoc) {
+    SourceLocation DepLoc, OpenMPPrefetchClauseKind PrefKind,
+    SourceLocation PrefLoc) {
   OMPClause *Res = nullptr;
   switch (Kind) {
   case OMPC_private:
@@ -5172,6 +5178,11 @@
     Res = ActOnOpenMPDependClause(DepKind, DepLoc, ColonLoc, VarList, StartLoc,
                                   LParenLoc, EndLoc);
     break;
+  case OMPC_prefetch:
+    Res = ActOnOpenMPPrefetchClause(PrefKind, PrefLoc, VarList, TailExpr,
+                                    EndExpr, StartLoc, LParenLoc, ColonLoc,
+                                    EndColonLoc, EndLoc);
+    break;
   case OMPC_if:
   case OMPC_final:
   case OMPC_num_threads:
@@ -6785,3 +6796,58 @@
                                  DepLoc, ColonLoc, Vars);
 }
 
+OMPClause *
+Sema::ActOnOpenMPPrefetchClause(OpenMPPrefetchClauseKind PrefKind,
+                                SourceLocation PrefLoc,
+                                ArrayRef<Expr *> VarList,
+                                Expr *Start, Expr *End,
+                                SourceLocation StartLoc,
+                                SourceLocation LParenLoc,
+                                SourceLocation FirstColonLoc,
+                                SourceLocation SecondColonLoc,
+                                SourceLocation EndLoc) {
+  // Check validity of range expressions & variables which use them
+  if(Start) {
+    if(!Start->getType()->isIntegerType()) {
+      Diag(Start->getExprLoc(), diag::err_omp_invalid_prefetch_range_type);
+      return nullptr;
+    }
+
+    if(End) {
+      if(!End->getType()->isIntegerType()) {
+        Diag(End->getExprLoc(), diag::err_omp_invalid_prefetch_range_type);
+        return nullptr;
+      }
+    }
+
+    for(const auto &Var : VarList) {
+      QualType T = Var->getType();
+
+      if(!T->isArrayType() && !T->isPointerType()) {
+        Diag(Var->getExprLoc(), diag::err_omp_invalid_prefetch_var_type)
+          << "array or pointer";
+        return nullptr;
+      }
+    }
+  }
+  else {
+    for(const auto &Var : VarList) {
+      // Note: array types with known sizes may be decayed to pointer types.
+      // We want the original type (i.e., the array type) but we can't simply
+      // call T.getDesugaredType() as it will return the pointer type.
+      QualType T = Var->getType();
+      while(isa<DecayedType>(T)) T = cast<DecayedType>(T)->getOriginalType();
+
+      if(!T->isConstantArrayType()) {
+        Diag(Var->getExprLoc(), diag::err_omp_invalid_prefetch_var_type)
+          << "constant-sized array";
+        return nullptr;
+      }
+    }
+  }
+
+  return OMPPrefetchClause::Create(Context, PrefKind, PrefLoc, VarList, Start,
+                                   End, StartLoc, LParenLoc, FirstColonLoc,
+                                   SecondColonLoc, EndLoc);
+}
+
Index: lib/Sema/TreeTransform.h
===================================================================
--- lib/Sema/TreeTransform.h	(revision 320332)
+++ lib/Sema/TreeTransform.h	(working copy)
@@ -7469,6 +7469,14 @@
       C->getLocStart(), C->getLParenLoc(), C->getLocEnd());
 }
 
+template <typename Derived>
+OMPClause *
+TreeTransform<Derived>::TransformOMPPrefetchClause(OMPPrefetchClause *C) {
+  // TODO Rob
+  llvm_unreachable("not yet implmented");
+  return C;
+}
+
 //===----------------------------------------------------------------------===//
 // Expression transformation
 //===----------------------------------------------------------------------===//
Index: lib/Serialization/ASTReaderStmt.cpp
===================================================================
--- lib/Serialization/ASTReaderStmt.cpp	(revision 320332)
+++ lib/Serialization/ASTReaderStmt.cpp	(working copy)
@@ -2065,6 +2065,11 @@
   C->setVarRefs(Vars);
 }
 
+void OMPClauseReader::VisitOMPPrefetchClause(OMPPrefetchClause *C) {
+  // TODO Rob
+  llvm_unreachable("not yet implemented");
+}
+
 //===----------------------------------------------------------------------===//
 // OpenMP Directives.
 //===----------------------------------------------------------------------===//
Index: lib/Serialization/ASTWriterStmt.cpp
===================================================================
--- lib/Serialization/ASTWriterStmt.cpp	(revision 320332)
+++ lib/Serialization/ASTWriterStmt.cpp	(working copy)
@@ -1916,6 +1916,11 @@
     Writer->Writer.AddStmt(VE);
 }
 
+void OMPClauseWriter::VisitOMPPrefetchClause(OMPPrefetchClause *C) {
+  // TODO Rob
+  llvm_unreachable("not yet implemented");
+}
+
 //===----------------------------------------------------------------------===//
 // OpenMP Directives.
 //===----------------------------------------------------------------------===//
Index: tools/libclang/CIndex.cpp
===================================================================
--- tools/libclang/CIndex.cpp	(revision 320332)
+++ tools/libclang/CIndex.cpp	(working copy)
@@ -2147,7 +2147,11 @@
 void OMPClauseEnqueue::VisitOMPDependClause(const OMPDependClause *C) {
   VisitOMPClauseList(C);
 }
+void OMPClauseEnqueue::VisitOMPPrefetchClause(const OMPPrefetchClause *C) {
+  // TODO Rob
+  llvm_unreachable("not yet implemented");
 }
+}
 
 void EnqueueVisitor::EnqueueChildren(const OMPClause *S) {
   unsigned size = WL.size();
