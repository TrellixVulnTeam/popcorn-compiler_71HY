         DARPA Scalable Synthetic Compact Application (SSCA) #1

                       Optimal Pattern Matching


The C program runSequenceAlignment is derived from the Matlab program
RUN_sequenceAlignment that was written by Bill Mann (formerly of MIT
Lincoln Labs) and distributed as version 0.6 of DARPA SSCA #1.  Whereas
the Matlab code is serial, the C code has been modified for parallel
execution under either OpenMP or MPI, following the suggestions given
in the "parallelization.txt" file that is included in the version 0.6
distribution.  In the present implementation, Kernels 1 and 2 of the
5-kernel Matlab code have been converted to C and parallelized.

The program operates as follows. A similarity or "scoring" matrix is
generated by genSimMatrix.c.  Two random sequences of amino acid codons
(which will be referred to as the "main" and "match" sequences) are generated
by genScalData.c, and then six pre-determined verification sequences are
embedded therein.  Then in Kernel 1 each OpenMP thread or MPI process compares
sub-sequences of the two sequences via the local-affine Smith-Waterman
algorithm, and builds a list of the best alignments and their endpoints.  These
lists may be optionally printed for each OpenMP thread or MPI process as
directed by several compile-time parameters.  Next, in Kernel 2A each OpenMP
thread or MPI process begins at each endpoint and follows each alignment back
to its start point, and outputs a list of the best alignments and their start
points, endpoints and codon sequences.  Kernel 2B merges the results of
Kernel 2A from all of the OpenMP threads or MPI processes, and outputs a final
list of the best alignments.

The various source files are as follows:

   sequenceAlignment.c - main program

   sequenceAlignment.h - compilation paramaters

   genSimMatrix.c - generate the similarity matrix

   genScalData.c - generate the random codon sequences

   verifyData.c - print details of the similarity matrix and sequences

   pairwiseAlign.c - perform the local-affine Smith-Waterman algorithm

   scanBackward.c - backtrack from each endpoint to find a startpoint

   verifyAlignment.c - report results of backtracking for each thread/process

   mergeAlignment.c - merge results from all OpenMP threads or MPI processes

   verifyMergeAlignment.c - report the results of the merge

   dispElapsedTime.c - measure the elapsed time


Three different versions of the executable may be built using three
different makefiles:

   Makefile - single threaded execution

   Makefile.omp - multiple threaded execution under OpenMP

   Makefile.mpi - multiple process execution under MPI


The program is executed by typing (in single threaded mode):

      runSequenceAlignment <scale>

or by typing (in OpenMP mode):

      setenv OMP_NUM_THREADS number_of_threads
      runSequenceAlignment <scale>

or by typing (in MPI mode):

      mpirun -np N <MPI options> runSequenceAlignment <scale>

where N is the number of processes.

The optional scale argument is interpreted as 2*log2(sequence length).  For
example, setting scale to 40 results in sequences that comprise 2^20 codons,
and a sequence alignment problem that performs 2^40 character comparisons.
The actual sequence length is a bit longer than 2^[(sequence length)/2]
because short verification sequences are embedded at random points into the
generated sequences.  The default value of scale is 30.  For parallel
execution, a value of scale less than 22 may give erroneous results because
each processor may not consider a sufficiently large sub-sequence to find
the verification sequences.

Random sequence generation is controlled by randomSeed which is set to 1
when ENABLE_VERIF is defined in the sequenceAlignment.h file.  When
ENABLE_VERIF is not defined, randomSeed is set by summing the time fields
that are returned by the C time() function and decoded by the localtime()
function.  This approach follows that of the Matlab code, but results will
differ Matlab because of differences in the random number generators between
Matlab and C.

The program may be compiled with various options that are specified in
the sequenceAlignment.h file.  The more important options are:

SCALE              - the default length of the generated sequences
MATCH_LIMIT        - length of the longest match to be reported for Kernel 2
K1_MAX_REPORTS     - maximum # of alignments reported by Kernel 1 to Kernel 2A
K2_MAX_REPORTS     - maximum # of alignments reported by Kernel 2B to Kernel 3A
K1_MIN_SEPARATION  - minimum start and endpoint separation for unique sequences
K2A_SUMMARY        - print a summary for each thread that executed Kernel 2A
K2A_REPORTS        - print reports for Kernel 2A
K2A_DISPLAY        - the number of reports to print for Kernel 2A
K2B_DISPLAY        - the number of reports to print for Kernel 2B
MINUS_INFINITY     - a large negative number for use by the doScan function

One major difference between the C code and the Matlab code is that the
C code uses integer arithmetic for Kernel 1, whereas the Matlab code uses
floating-point arithmetic.  Another difference is that the Matlab code uses
the Matlab sort() function to sort good sequence matches, whereas the C code
uses bubble sort.  The particular sort used is not of great importance because
the sort is applied to the "reports" that are generated by the kernels, and at
present the maximum number of reports is 200.  If, however, the number of
reports were to be increased significantly via K1_ or K2_MAX_REPORTS,
then it is possible that the particular form or sort would become important.
Also, there are several places in the code where insertion or deletion of
a report occurs via a process that is similar to bubble sort and hence
exhibits O(n^2) computational complexity.  If the maximum number of reports
were to be increased significantly, some attention might be given to these
insertions and deletions.

Correct operation of the Smith-Waterman algorithm may be verified by the
presence of the following six verification sequences at the top of the list
of alignments that is output following execution of Kernel 2B.  The starting
and ending positions are unimportant.  The amino acids column (*SIMILARTESTS*,
*PARTIALCASES*, *IDENTICAL*, *MISQRMATCHES*, *STARTGAPMIDST---END* and
*EVENLESSWKDPALIGNS*) and scores (52 to 57) are important:

Starting   Amino     Codon           Ending
position   acids     bases           position

verifyMergeAlignment 1, succeeded; score 57
  14827  *SIMILARTESTS*  tgaagcataatgatactggcgaggacggagagcacgagctga    14840
  10295  *SIMILARTESTS*  taatctattatgattttggctcgtactgaatctacttcttaa    10308

verifyMergeAlignment 2, succeeded; score 56
   1734  *PARTIALCASES*  tgaccggcgaggacgatagcgctgtgcgcgagcgagagctga     1747
   5346  *PARTIALCASES*  taacctgctcgtactattgctttgtgtgcttctgaatcttaa     5359

verifyMergeAlignment 3, succeeded; score 55
   6877  *IDENTICAL*  tgaatagacgagaacacgatatgcgcgctgtga     6887
   4187  *IDENTICAL*  tgaatagacgagaacacgatatgcgcgctgtga     4197

verifyMergeAlignment 4, succeeded; score 54
   4250  *MISQRMATCHES*  tgaatgataagccagaggatggcgacgtgccacgagagctga     4263
   1293  *MISRQMATCHES*  tgaatgataagcaggcagatggcgacgtgccacgagagctga     1306

verifyMergeAlignment 5, succeeded; score 53
    998  *STARTGAPMIDST---END*  tgaagcacggcgaggacgggggcgccgatgatagacagcacg---------gagaacgactga     1015
  13243  *START---MIDSTGAPEND*  tgaagcacggcgaggacg---------atgatagacagcacgggggcgccggagaacgactga    13260

verifyMergeAlignment 6, succeeded; score 52
  16509  *EVENLESSWKDPALIGNS*  tgagaggtggagaacctggagagcagctggaaggacccggcgctgatagggaacagctga    16528
   2328  *EVENLESSTVMFALIGNS*  taagaagttgaaaatttggaatcttctactgttatgtttgctttgattggtaattcttaa     2347

Note that these verification sequences have alignment scores of 52 to 57.  Any other
alignment sequences that may arise in the random sequences ought to have alignment
scores that are considerably less than 52 and no larger than about 45 for random
sequences less than 2^20 in length that correspond to a scale variable of 2^40.  In
general, the alignment scores for random sequences will increase with increasing
lengths of random sequences.
