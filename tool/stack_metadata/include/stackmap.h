/**
 * Data structures for stack maps generated by LLVM.
 *
 * Note: Register numbers correspond to the architecture-specific DWARF
 * register mapping.
 *
 * Author: Rob Lyerly <rlyerly@vt.edu>
 * Date: 5/25/2016
 */

/*
 * NOTE: PLEASE READ ME FIRST!
 *
 * If you change the format of any of the structs below you *must* recompile &
 * reinstall any libraries that require stackmaps including (but not limited
 * to):
 *
 *   libc (musl-libc)
 *   libmigrate (migration)
 *   libopenpop
 */

#ifndef _STACKMAP_H
#define _STACKMAP_H

#include "definitions.h"
#include "bin.h"
#include "rewrite_metadata.h"

/*
 * Function address, function on-stack size and references to function
 * activation metadata contained in other sections.
 */
typedef struct POPCORN_PACKED stackmap_function {
  uint64_t addr; /* function address */
  uint64_t frame_size; /* size of the stack frame */
} stackmap_function;

/* A live register across the stack map call. */
typedef struct POPCORN_PACKED live_out_record {
  uint16_t regnum;
  uint8_t reserved;
  uint8_t size; /* in bytes */
} live_out_record;

/* A stack map record for a call site. */
// Note: this doesn't directly mirror on-disk layout, as the on-disk records
// are variably sized.
typedef struct POPCORN_PACKED call_site_record {
  /* Call site header */
  uint64_t id; /* per-call site ID */
  uint32_t func_idx : 31; /* index into function_records for function information */
  // TODO unhandled should be removed once the compiler better handles all values
  uint32_t unhandled : 1; /* did the compiler find unhandled values? */
  uint32_t offset; /* offset from beginning of function */
  uint16_t reserved;

  /* Live value locations */
  uint16_t num_locations;
  live_value *locations;
  uint16_t padding;

  /* Register live-outs */
  uint16_t num_live_outs;
  live_out_record *live_outs;
  uint16_t padding2;

  /* Architecture-specific live values */
  uint16_t num_arch_live;
  arch_live_value *arch_live;
} call_site_record;

/* Per-module stack map information. */
typedef struct POPCORN_PACKED stack_map_section {
  /* Header */
  uint8_t version;
  uint8_t reserved;
  uint16_t reserved2;

  /* Counts of encoded functions, constants and call site records. */
  uint32_t num_functions;
  uint32_t num_constants;
  uint32_t num_records;

  /* Function records */
  stackmap_function *function_records;

  /* Constant pool entries */
  uint64_t *constants;

  /* Stack map call site records */
  call_site_record *call_sites;
} stack_map_section;

/**
 * Read stack map information from a binary.
 * @param b a binary
 * @param sm a pointer that will be initialized to an array of stack map
 *        structs
 * @param num_sm number of stackmap structs parsed
 * @return 0 if successful, an error code otherwise
 */
ret_t init_stackmap(bin *b, stack_map_section **sm_ptr, size_t *num_sm);

/**
 * Free stack map data.
 * @param sm stack maps
 * @param num_sm number of stack maps
 * @return 0 if successful, an error code otherwise
 */
ret_t free_stackmaps(stack_map_section *sm, size_t num_sm);

#endif

